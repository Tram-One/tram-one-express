// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"6LJCz":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "4a236f9275d0a351";
module.bundle.HMR_BUNDLE_ID = "2dece85321b8d0fd";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    var parents = getParents(module.bundle.root, id); // If no parents, the asset is new. Prevent reloading the page.
    if (!parents.length) return true;
    return parents.some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"4FN3P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "app", ()=>app
);
parcelHelpers.export(exports, "startApp", ()=>startApp
);
var _tramOne = require("../../src/tram-one");
var _elementRendering = require("./element-rendering");
var _elementRenderingDefault = parcelHelpers.interopDefault(_elementRendering);
var _elementSwitcher = require("./element-switcher");
var _elementSwitcherDefault = parcelHelpers.interopDefault(_elementSwitcher);
const useUrlParams = require('use-url-params');
const html = _tramOne.registerHtml({
    'element-rendering': _elementRenderingDefault.default,
    'element-switcher': _elementSwitcherDefault.default
});
const app = ()=>{
    if (useUrlParams('/element-rendering').matches) return html`<div><element-rendering /></div>`;
    if (useUrlParams('/element-switcher').matches) return html`<div><element-switcher /></div>`;
    return html`
		<main>
			<h1>Performance Test App</h1>
		</main>
	`;
};
const startApp = (container)=>{
    let appContainer = container;
    if (!appContainer) {
        // before we setup the app, cleanup the document state if this was called before
        const previousApp = document.querySelector('#app');
        if (previousApp) previousApp.remove();
        // setup the container for the app
        appContainer = document.createElement('div');
        appContainer.id = 'app';
        // attach the container to the document
        // this is required, since focus and visibility checks depend on being in the document
        window.document.body.appendChild(appContainer);
    }
    _tramOne.start(app, appContainer);
    return {
        container: appContainer
    };
};
if (document.querySelector('#parcel-page')) startApp('#parcel-page');

},{"use-url-params":"cmhaZ","../../src/tram-one":"3dkvQ","./element-rendering":"5yNmg","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV","./element-switcher":"gLVVv"}],"cmhaZ":[function(require,module,exports) {
const setupUrlParams = require('./setupUrlParams');
const useUrlParams = require('./useUrlParams');
module.exports = useUrlParams;
useUrlParams.setupUrlParams = setupUrlParams;
useUrlParams.useUrlParams = useUrlParams;

},{"./setupUrlParams":"fkg6w","./useUrlParams":"3TA6r"}],"fkg6w":[function(require,module,exports) {
const urlParamHook = require('./urlParamHook');
/**
 * @see https://tram-one.io/api/#Tram-One#useUrlParams
 * @name useUrlParams
 *
 * @param {function} [getPath] - function to return the current path, defaults to reading window.location.href
 * @returns the useUrlParams hook
 */ module.exports = urlParamHook;

},{"./urlParamHook":"lyHzk"}],"lyHzk":[function(require,module,exports) {
const rlite = require('rlite-router');
const onNonMatchingPath = ()=>({
        matches: false
    })
;
const returnParams = (params)=>({
        matches: true,
        ...params
    })
;
module.exports = (getPath)=>(pattern = '*')=>rlite(onNonMatchingPath, {
            [pattern]: returnParams
        })(getPath())
;

},{"rlite-router":"68IAI"}],"68IAI":[function(require,module,exports) {
(function(root, factory) {
    var define = root && root.define;
    if (define && define.amd) define('rlite', [], factory);
    else if (typeof module !== 'undefined' && module.exports) module.exports = factory();
    else root.Rlite = factory();
})(this, function() {
    return function(notFound, routeDefinitions) {
        var routes = {
        };
        var decode = decodeURIComponent;
        init();
        function init() {
            for(var key in routeDefinitions){
                add(key, routeDefinitions[key]);
            }
        }
        function noop(s) {
            return s;
        }
        function sanitize(url) {
            ~url.indexOf('/?') && (url = url.replace('/?', '?'));
            url[0] == '/' && (url = url.slice(1));
            url[url.length - 1] == '/' && (url = url.slice(0, -1));
            return url;
        }
        // Recursively searches the route tree for a matching route
        // pieces: an array of url parts, ['users', '1', 'edit']
        // esc: the function used to url escape values
        // i: the index of the piece being processed
        // rules: the route tree
        // params: the computed route parameters (this is mutated), and is a stack since we don't have fast immutable datatypes
        //
        // This attempts to match the most specific route, but may end int a dead-end. We then attempt a less specific
        // route, following named route parameters. In searching this secondary branch, we need to make sure to clear
        // any route params that were generated during the search of the dead-end branch.
        function recurseUrl(pieces, esc, i, rules, params) {
            if (!rules) {
                return;
            }
            if (i >= pieces.length) {
                var cb = rules['@'];
                return cb && {
                    cb: cb,
                    params: params.reduce(function(h, kv) {
                        h[kv[0]] = kv[1];
                        return h;
                    }, {
                    })
                };
            }
            var piece = esc(pieces[i]);
            var paramLen = params.length;
            return recurseUrl(pieces, esc, i + 1, rules[piece.toLowerCase()], params) || recurseNamedUrl(pieces, esc, i + 1, rules, ':', piece, params, paramLen) || recurseNamedUrl(pieces, esc, pieces.length, rules, '*', pieces.slice(i).join('/'), params, paramLen);
        }
        // Recurses for a named route, where the name is looked up via key and associated with val
        function recurseNamedUrl(pieces, esc, i, rules, key, val, params, paramLen) {
            params.length = paramLen; // Reset any params generated in the unsuccessful search branch
            var subRules = rules[key];
            subRules && params.push([
                subRules['~'],
                val
            ]);
            return recurseUrl(pieces, esc, i, subRules, params);
        }
        function processQuery(url, ctx, esc) {
            if (url && ctx.cb) {
                var hash = url.indexOf('#'), query = (hash < 0 ? url : url.slice(0, hash)).split('&');
                for(var i = 0; i < query.length; ++i){
                    var nameValue = query[i].split('=');
                    ctx.params[nameValue[0]] = esc(nameValue[1]);
                }
            }
            return ctx;
        }
        function lookup(url) {
            var querySplit = sanitize(url).split('?');
            var esc = ~url.indexOf('%') ? decode : noop;
            return processQuery(querySplit[1], recurseUrl(querySplit[0].split('/'), esc, 0, routes, []) || {
            }, esc);
        }
        function add(route, handler) {
            var pieces = route.split('/');
            var rules = routes;
            for(var i = +(route[0] === '/'); i < pieces.length; ++i){
                var piece = pieces[i];
                var name = piece[0] == ':' ? ':' : piece[0] == '*' ? '*' : piece.toLowerCase();
                rules = rules[name] || (rules[name] = {
                });
                (name == ':' || name == '*') && (rules['~'] = piece.slice(1));
            }
            rules['@'] = handler;
        }
        function run(url, arg) {
            var result = lookup(url);
            return (result.cb || notFound)(result.params, arg, url);
        }
        return run;
    };
});

},{}],"3TA6r":[function(require,module,exports) {
const urlParamHook = require('./urlParamHook');
const defaultGetPath = ()=>window.location.href.replace(window.location.origin, '')
;
/**
 * @see https://tram-one.io/api/#Tram-One#useUrlParams
 *
 * @description
 * Hook that returns path variables based on the route.
 * Can return path parameters, query params, and more.
 * It's internal functionality is powered by the package
 * {@link https://www.npmjs.com/package/rlite-router | rlite}
 *
 * Rather than using XML templates to define routes, this method enables
 * routing in javascript.
 *
 * @param {String} [pattern] path for resolving path parameters (not required for query params)
 *
 * @returns {Object} object with a `matches` key, and (if it matched) path and query parameters
 */ module.exports = urlParamHook(defaultGetPath);

},{"./urlParamHook":"lyHzk"}],"3dkvQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerHtml", ()=>_domWrappers.registerHtml
);
parcelHelpers.export(exports, "registerSvg", ()=>_domWrappers.registerSvg
);
parcelHelpers.export(exports, "useEffect", ()=>_useEffectDefault.default
);
parcelHelpers.export(exports, "useUrlParams", ()=>_useUrlParamsDefault.default
);
parcelHelpers.export(exports, "useStore", ()=>_useStoreDefault.default
);
parcelHelpers.export(exports, "useGlobalStore", ()=>_useGlobalStoreDefault.default
);
parcelHelpers.export(exports, "start", ()=>_startDefault.default
);
parcelHelpers.export(exports, "ElementOrSelector", ()=>_types.ElementOrSelector
);
parcelHelpers.export(exports, "DOMTaggedTemplateFunction", ()=>_types.DOMTaggedTemplateFunction
);
parcelHelpers.export(exports, "TramOneComponent", ()=>_types.TramOneComponent
);
parcelHelpers.export(exports, "StoreObject", ()=>_types.StoreObject
);
parcelHelpers.export(exports, "CleanupEffect", ()=>_types.CleanupEffect
);
parcelHelpers.export(exports, "Effect", ()=>_types.Effect
);
parcelHelpers.export(exports, "Props", ()=>_types.Props
);
parcelHelpers.export(exports, "Registry", ()=>_types.Registry
);
parcelHelpers.export(exports, "UrlMatchResults", ()=>_types.UrlMatchResults
);
parcelHelpers.export(exports, "TramOneElement", ()=>_types.TramOneElement
);
var _domWrappers = require("./dom-wrappers");
var _useEffect = require("./use-effect");
var _useEffectDefault = parcelHelpers.interopDefault(_useEffect);
var _useUrlParams = require("./use-url-params");
var _useUrlParamsDefault = parcelHelpers.interopDefault(_useUrlParams);
var _useStore = require("./use-store");
var _useStoreDefault = parcelHelpers.interopDefault(_useStore);
var _useGlobalStore = require("./use-global-store");
var _useGlobalStoreDefault = parcelHelpers.interopDefault(_useGlobalStore);
var _start = require("./start");
var _startDefault = parcelHelpers.interopDefault(_start);
var _types = require("./types");

},{"./dom-wrappers":"bABP7","./use-effect":"59Xs2","./use-url-params":"bMUmG","./use-store":"cZPHV","./use-global-store":"bH0Nk","./start":"2PwLl","./types":"9DyTH","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bABP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerHtml", ()=>registerHtml
);
parcelHelpers.export(exports, "registerSvg", ()=>registerSvg
);
var _dom = require("./dom");
const registerHtml = (registry)=>{
    return _dom.registerDom(null, registry);
};
const registerSvg = (registry)=>{
    return _dom.registerDom('http://www.w3.org/2000/svg', registry);
};

},{"./dom":"9Csud","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9Csud":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerDom", ()=>registerDom
);
var _engineNames = require("./engine-names");
var _workingKey = require("./working-key");
var _observeTag = require("./observe-tag");
var _observeTagDefault = parcelHelpers.interopDefault(_observeTag);
var _processEffects = require("./process-effects");
var _processEffectsDefault = parcelHelpers.interopDefault(_processEffects);
var _nodeNames = require("./node-names");
const nanohtml = require('@tram-one/nanohtml');
const rbel = require('@tram-one/rbel');
const hyperx = require('@tram-one/hyperx');
const registerDom = (namespace, registry = {
})=>{
    // modify the registry so that each component function updates the hook working key
    const hookedRegistry = Object.keys(registry).reduce((newRegistry, tagName)=>{
        const tagFunction = registry[tagName];
        const hookedTagFunction = (props, children)=>{
            // push a new branch onto the working key so any values that need to be unique among components
            // but consistent across renders can be read
            const stringifiedProps = JSON.stringify(props);
            const newBranch = `${tagName}[${stringifiedProps}]`;
            _workingKey.pushWorkingKeyBranch(_engineNames.TRAM_HOOK_KEY, newBranch);
            // increment branch so that we have a unique value (in case we are rendering a list of components)
            _workingKey.incrementWorkingKeyBranch(_engineNames.TRAM_HOOK_KEY);
            const uniqueBranch = _workingKey.copyWorkingKey(_engineNames.TRAM_HOOK_KEY);
            // create a tag function that has the args passed in
            const populatedTagFunction = ()=>{
                // reset working key so we have the correct place when starting a new component
                _workingKey.restoreWorkingKey(_engineNames.TRAM_HOOK_KEY, uniqueBranch);
                return tagFunction(props, children);
            };
            // observe store usage and process any new effects that were called when building the component
            const processEffectsAndBuildTagResult = ()=>_processEffectsDefault.default(populatedTagFunction)
            ;
            const tagResult = _observeTagDefault.default(processEffectsAndBuildTagResult);
            // pop the branch off (since we are done rendering this component)
            _workingKey.popWorkingKeyBranch(_engineNames.TRAM_HOOK_KEY);
            // decorate the properties expected on TramOneElements (see node-names.ts)
            tagResult[_nodeNames.TRAM_TAG] = true;
            // we won't decorate TRAM_TAG_REACTION, that needs to be done later when we observe the tag
            tagResult[_nodeNames.TRAM_TAG_NEW_EFFECTS] = tagResult[_nodeNames.TRAM_TAG_NEW_EFFECTS] || [];
            tagResult[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS] = tagResult[_nodeNames.TRAM_TAG_NEW_EFFECTS] || [];
            return tagResult;
        };
        return {
            ...newRegistry,
            [tagName]: hookedTagFunction
        };
    }, {
    });
    return rbel(hyperx, nanohtml(namespace), hookedRegistry);
};

},{"@tram-one/nanohtml":"d7iMI","@tram-one/rbel":"fi7y5","@tram-one/hyperx":"04AW1","./engine-names":"bWqq3","./working-key":"hOltX","./observe-tag":"1BjnD","./process-effects":"djlQI","./node-names":"jE2wn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"d7iMI":[function(require,module,exports) {
const appendChild = require('./appendChild');
const COMMENT_TAG = '!--';
// filters for attributes
const isNotXMLNSprop = (prop)=>!/^xmlns($|:)/i.test(prop)
;
const containsOwnProp = (props)=>(prop)=>Object.prototype.hasOwnProperty.call(props, prop)
;
// map to objects so we know their value
const toObjectList = (props)=>(prop)=>({
            key: prop,
            value: props[prop]
        })
;
// transformations for attributes
const normalizeClassName = (prop)=>prop.key.toLowerCase() === 'classname' ? {
        key: 'class',
        value: prop.value
    } : prop
;
const htmlForToFor = (prop)=>prop.key === 'htmlFor' ? {
        key: 'for',
        value: prop.value
    } : prop
;
const addEventToElement = (element, eventKey, eventValue)=>{
    element[eventKey] = eventValue;
    // add event to element list of events
    element.events = element.events ? element.events.concat(eventKey) : [
        eventKey
    ];
};
// handlers that can be filtered on
// if something gets processed, we return false
// otherwise, it returns true, indicating that this thing needs to be processed
const handleEventSetter = (element)=>(prop)=>prop.key.slice(0, 2) === 'on' ? addEventToElement(element, prop.key, prop.value) : true
;
const handleAttrSetter = (element)=>(prop)=>element.setAttributeNS(null, prop.key, prop.value)
;
const nanoCreateElement = (namespace)=>(tag, props, children)=>{
        // if the tag is a comment
        if (tag === COMMENT_TAG) return document.createComment(props.comment);
        // create the element
        const element = namespace ? document.createElementNS(namespace, tag) : document.createElement(tag);
        // attach the properties
        Object.keys(props).filter(isNotXMLNSprop).filter(containsOwnProp(props)).map(toObjectList(props)).map(normalizeClassName).map(htmlForToFor).filter(handleEventSetter(element)).filter(handleAttrSetter(element));
        appendChild(element, children);
        return element;
    }
;
module.exports = nanoCreateElement;
module.exports.html = nanoCreateElement();
module.exports.svg = nanoCreateElement('http://www.w3.org/2000/svg');

},{"./appendChild":"6zZE5"}],"6zZE5":[function(require,module,exports) {
const parseNodeAsString = (node)=>typeof node === 'number' || typeof node === 'boolean' || typeof node === 'function' || node instanceof Date || node instanceof RegExp ? node.toString() : node
;
const isNotWhitespace = (node)=>!(typeof node === 'string' && /^[\n\r\s]+$/.test(node))
;
const appendChild = (element, childs)=>{
    if (!Array.isArray(childs)) return;
    childs.map(parseNodeAsString).filter(isNotWhitespace).forEach((node)=>{
        if (Array.isArray(node)) {
            appendChild(element, node);
            return;
        }
        if (typeof node === 'string') {
            if (element.lastChild && element.lastChild.nodeName === '#text') {
                element.lastChild.nodeValue += node;
                return;
            }
            node = document.createTextNode(node);
        }
        if (node && node.nodeType) element.appendChild(node);
    });
};
module.exports = appendChild;

},{}],"fi7y5":[function(require,module,exports) {
module.exports = function(domBuilder, h, components) {
    const eh = function(tagName, attrs, children) {
        const component = components[tagName];
        const node = component ? component(attrs, children) : h(tagName, attrs, children);
        return node;
    };
    const hx = domBuilder(eh);
    hx.h = eh;
    return hx;
};

},{}],"04AW1":[function(require,module,exports) {
const attrToProp = require('hyperscript-attribute-to-property');
const VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4, ATTR_KEY = 5, ATTR_KEY_W = 6, ATTR_VALUE_W = 7, ATTR_VALUE = 8, ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10, ATTR_EQ = 11, ATTR_BREAK = 12, COMMENT = 13, SELF_CLOSE = 14;
module.exports = function(h, opts) {
    if (!opts) opts = {
        comments: true
    };
    const concat = opts.concat || function(a, b) {
        return String(a) + String(b);
    };
    const strfn = (x)=>{
        switch(typeof x){
            case 'function':
            case 'string':
            case 'object':
            case 'undefined':
                return x;
            default:
                return concat('', x);
        }
    };
    if (opts.attrToProp !== false) h = attrToProp(h);
    return function(strings) {
        var state = TEXT, reg = '';
        var arglen = arguments.length;
        var parts = [];
        for(var i = 0; i < strings.length; i++)if (i < arglen - 1) {
            var arg = arguments[i + 1];
            var p = parse(strings[i]);
            var xstate = state;
            switch(xstate){
                case COMMENT:
                    reg += arg;
                    arg = '';
                case ATTR_VALUE_DQ:
                case ATTR_VALUE_SQ:
                case ATTR_VALUE_W:
                    xstate = ATTR_VALUE;
                    break;
                case ATTR:
                    xstate = ATTR_KEY;
                    break;
            }
            p.push([
                VAR,
                xstate,
                arg
            ]);
            parts.push.apply(parts, p);
        } else parts.push.apply(parts, parse(strings[i]));
        var tree = [
            null,
            {
            },
            []
        ];
        var stack = [
            [
                tree,
                -1
            ]
        ];
        for(var i = 0; i < parts.length; i++){
            var cur = stack[stack.length - 1][0];
            var p = parts[i], s = p[0];
            if (s === OPEN && /^\//.test(p[1])) {
                var ix = stack[stack.length - 1][1];
                if (stack.length > 1) {
                    stack.pop();
                    stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : undefined);
                }
            } else if (s === OPEN) {
                var c = [
                    p[1],
                    {
                    },
                    []
                ];
                cur[2].push(c);
                stack.push([
                    c,
                    cur[2].length - 1
                ]);
            } else if (s === ATTR_KEY || s === VAR && p[1] === ATTR_KEY) {
                var key = '';
                var copyKey;
                for(; i < parts.length; i++){
                    if (parts[i][0] === ATTR_KEY) key = concat(key, parts[i][1]);
                    else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
                        if (typeof parts[i][2] === 'object' && !key) {
                            for(copyKey in parts[i][2])if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) cur[1][copyKey] = parts[i][2][copyKey];
                        } else key = concat(key, parts[i][2]);
                    } else break;
                }
                if (parts[i][0] === ATTR_EQ) i++;
                var j = i;
                for(; i < parts.length; i++){
                    if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
                        if (!cur[1][key]) cur[1][key] = strfn(parts[i][1]);
                        else parts[i][1] === "" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
                    } else if (parts[i][0] === VAR && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
                        if (!cur[1][key]) cur[1][key] = strfn(parts[i][2]);
                        else parts[i][2] === "" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
                    } else {
                        if (key.length && !cur[1][key] && i === j && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
                        // empty string is falsy, not well behaved value in browser
                        cur[1][key] = key.toLowerCase();
                        if (parts[i][0] === CLOSE) i--;
                        break;
                    }
                }
            } else if (s === SELF_CLOSE) {
                var ix = stack[stack.length - 1][1];
                stack.pop();
                stack[stack.length - 1][0][2][ix] = h(cur[0], cur[1], cur[2].length ? cur[2] : undefined);
            } else if (s === VAR && p[1] === TEXT) {
                if (p[2] === undefined || p[2] === null) p[2] = '';
                else if (!p[2]) p[2] = concat('', p[2]);
                if (Array.isArray(p[2][0])) cur[2].push.apply(cur[2], p[2]);
                else cur[2].push(p[2]);
            } else if (s === TEXT) cur[2].push(p[1]);
            else if (s === ATTR_EQ || s === ATTR_BREAK || s === CLOSE) ;
            else throw new Error('unhandled: ' + s);
        }
        if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) tree[2].shift();
        if (tree[2].length > 2 || tree[2].length === 2 && /\S/.test(tree[2][1])) throw new Error('multiple root elements must be wrapped in an enclosing tag');
        if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string' && Array.isArray(tree[2][0][2])) tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2]);
        function parse(str) {
            var res = [];
            if (state === ATTR_VALUE_W) state = ATTR;
            for(var i = 0; i < str.length; i++){
                var c = str.charAt(i);
                if (state === COMMENT) {
                    // ignore until we get to close comment
                    if (/-$/.test(reg) && c === '-') {
                        if (opts.comments) {
                            res.push([
                                ATTR_VALUE,
                                reg.substr(0, reg.length - 1)
                            ], [
                                CLOSE
                            ]);
                        }
                        reg = '';
                        state = TEXT;
                    } else {
                        reg += c;
                        continue;
                    }
                }
                if (state === TEXT && c === '<') {
                    if (reg.length) res.push([
                        TEXT,
                        reg
                    ]);
                    reg = '';
                    state = OPEN;
                } else if (c === '>' && str.charAt(i - 1) === '/') {
                    res.push([
                        SELF_CLOSE
                    ]);
                    reg = '';
                    state = TEXT;
                } else if (c === '>' && str.charAt(i - 1) === '-' && str.charAt(i - 2) === '-') {
                    res.push([
                        SELF_CLOSE
                    ]);
                    reg = '';
                    state = TEXT;
                } else if (c === '>' && !quot(state) && state !== COMMENT) {
                    if (state === OPEN) {
                        res.push([
                            OPEN,
                            reg
                        ]);
                    } else if (state === ATTR_KEY) {
                        res.push([
                            ATTR_KEY,
                            reg
                        ]);
                    } else if (state === ATTR_VALUE && reg.length) {
                        res.push([
                            ATTR_VALUE,
                            reg
                        ]);
                    }
                    res.push([
                        CLOSE
                    ]);
                    reg = '';
                    state = TEXT;
                } else if (state === OPEN && /^!--$/.test(reg)) {
                    if (opts.comments) {
                        res.push([
                            OPEN,
                            reg
                        ], [
                            ATTR_KEY,
                            'comment'
                        ], [
                            ATTR_EQ
                        ]);
                    }
                    reg = c;
                    state = COMMENT;
                } else if (state === TEXT) {
                    reg += c;
                } else if (state === OPEN && c === '/' && reg.length) {
                    res.push([
                        OPEN,
                        reg
                    ]);
                    reg = '';
                    state = TEXT;
                } else if (state === OPEN && /\s/.test(c)) {
                    res.push([
                        OPEN,
                        reg
                    ]);
                    reg = '';
                    state = ATTR;
                } else if (state === OPEN) {
                    reg += c;
                } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
                    state = ATTR_KEY;
                    reg = c;
                } else if (state === ATTR && /\s/.test(c)) {
                    if (reg.length) res.push([
                        ATTR_KEY,
                        reg
                    ]);
                    res.push([
                        ATTR_BREAK
                    ]);
                } else if (state === ATTR_KEY && /\s/.test(c)) {
                    res.push([
                        ATTR_KEY,
                        reg
                    ]);
                    reg = '';
                    state = ATTR_KEY_W;
                } else if (state === ATTR_KEY && c === '=') {
                    res.push([
                        ATTR_KEY,
                        reg
                    ], [
                        ATTR_EQ
                    ]);
                    reg = '';
                    state = ATTR_VALUE_W;
                } else if (state === ATTR_KEY) {
                    reg += c;
                } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
                    res.push([
                        ATTR_EQ
                    ]);
                    state = ATTR_VALUE_W;
                } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
                    res.push([
                        ATTR_BREAK
                    ]);
                    if (/[\w-]/.test(c)) {
                        reg += c;
                        state = ATTR_KEY;
                    } else state = ATTR;
                } else if (state === ATTR_VALUE_W && c === '"') {
                    state = ATTR_VALUE_DQ;
                } else if (state === ATTR_VALUE_W && c === "'") {
                    state = ATTR_VALUE_SQ;
                } else if (state === ATTR_VALUE_DQ && c === '"') {
                    res.push([
                        ATTR_VALUE,
                        reg
                    ], [
                        ATTR_BREAK
                    ]);
                    reg = '';
                    state = ATTR;
                } else if (state === ATTR_VALUE_SQ && c === "'") {
                    res.push([
                        ATTR_VALUE,
                        reg
                    ], [
                        ATTR_BREAK
                    ]);
                    reg = '';
                    state = ATTR;
                } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
                    state = ATTR_VALUE;
                    i--;
                } else if (state === ATTR_VALUE && /\s/.test(c)) {
                    res.push([
                        ATTR_VALUE,
                        reg
                    ], [
                        ATTR_BREAK
                    ]);
                    reg = '';
                    state = ATTR;
                } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ) {
                    reg += c;
                }
            }
            if (reg.length) {
                switch(state){
                    case TEXT:
                        res.push([
                            TEXT,
                            reg
                        ]);
                        reg = '';
                        break;
                    case ATTR_VALUE:
                    case ATTR_VALUE_DQ:
                    case ATTR_VALUE_SQ:
                        res.push([
                            ATTR_VALUE,
                            reg
                        ]);
                        reg = '';
                        break;
                }
            }
            if (state === ATTR_KEY) {
                res.push([
                    ATTR_KEY,
                    reg
                ]);
                reg = '';
            }
            return res;
        }
        return tree[2][0];
    };
};
const quot = (state)=>state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ
;

},{"hyperscript-attribute-to-property":"6YDQR"}],"6YDQR":[function(require,module,exports) {
module.exports = attributeToProperty;
var transform = {
    'class': 'className',
    'for': 'htmlFor',
    'http-equiv': 'httpEquiv'
};
function attributeToProperty(h) {
    return function(tagName, attrs, children) {
        for(var attr in attrs)if (attr in transform) {
            attrs[transform[attr]] = attrs[attr];
            delete attrs[attr];
        }
        return h(tagName, attrs, children);
    };
}

},{}],"bWqq3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TRAM_HOOK_KEY", ()=>TRAM_HOOK_KEY
);
parcelHelpers.export(exports, "TRAM_EFFECT_STORE", ()=>TRAM_EFFECT_STORE
);
parcelHelpers.export(exports, "TRAM_EFFECT_QUEUE", ()=>TRAM_EFFECT_QUEUE
);
parcelHelpers.export(exports, "TRAM_OBSERVABLE_STORE", ()=>TRAM_OBSERVABLE_STORE
);
parcelHelpers.export(exports, "TRAM_MUTATION_OBSERVER", ()=>TRAM_MUTATION_OBSERVER
);
const TRAM_HOOK_KEY = 'tram-hook-key';
const TRAM_EFFECT_STORE = 'tram-effect-store';
const TRAM_EFFECT_QUEUE = 'tram-effect-queue';
const TRAM_OBSERVABLE_STORE = 'tram-observable-store';
const TRAM_MUTATION_OBSERVER = 'tram-mutation-observer';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"ciiiV":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"hOltX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupWorkingKey", ()=>setupWorkingKey
);
parcelHelpers.export(exports, "getWorkingKey", ()=>getWorkingKey
);
parcelHelpers.export(exports, "pushWorkingKeyBranch", ()=>pushWorkingKeyBranch
);
parcelHelpers.export(exports, "popWorkingKeyBranch", ()=>popWorkingKeyBranch
);
parcelHelpers.export(exports, "incrementWorkingKeyBranch", ()=>incrementWorkingKeyBranch
);
parcelHelpers.export(exports, "getWorkingKeyValue", ()=>getWorkingKeyValue
);
parcelHelpers.export(exports, "copyWorkingKey", ()=>copyWorkingKey
);
parcelHelpers.export(exports, "restoreWorkingKey", ()=>restoreWorkingKey
);
var _namespace = require("./namespace");
/*
 * This file defines all the functions required to interact with
 * a working-key object. This working-key object is used to help
 * hooks understand where in the mounting process we are, and what
 * values or effects to pull / trigger.
 */ const defaultWorkingKey = {
    // list of custom tags that we've stepped into
    branch: [],
    // map of branches to index value (used as a cursor for hooks)
    branchIndices: {
        '': 0
    }
};
const { setup: setupWorkingKey , get: getWorkingKey  } = _namespace.buildNamespace(()=>defaultWorkingKey
);
const getWorkingBranch = (keyName)=>{
    const workingkeyObject = getWorkingKey(keyName);
    return workingkeyObject.branch.join('/');
};
const pushWorkingKeyBranch = (keyName, branch)=>{
    const workingKey = getWorkingKey(keyName);
    workingKey.branch.push(branch);
    if (!workingKey.branchIndices[getWorkingBranch(keyName)]) workingKey.branchIndices[getWorkingBranch(keyName)] = 0;
};
const popWorkingKeyBranch = (keyName)=>{
    const workingKey = getWorkingKey(keyName);
    workingKey.branch.pop();
};
const incrementWorkingKeyBranch = (keyName)=>{
    const workingKey = getWorkingKey(keyName);
    workingKey.branchIndices[getWorkingBranch(keyName)] += 1;
};
const getWorkingKeyValue = (keyName)=>{
    const workingKey = getWorkingKey(keyName);
    const index = workingKey.branchIndices[getWorkingBranch(keyName)];
    return `${getWorkingBranch(keyName)}[${index}]`;
};
const copyWorkingKey = (keyName)=>{
    const key = getWorkingKey(keyName);
    return {
        branch: [
            ...key.branch
        ],
        branchIndices: {
            ...key.branchIndices
        }
    };
};
const restoreWorkingKey = (keyName, restoreKey)=>{
    const key = getWorkingKey(keyName);
    const branches = key.branchIndices;
    key.branch = [
        ...restoreKey.branch
    ];
    const resetBranchValue = (branch)=>{
        branches[branch] = restoreKey.branchIndices[branch] || 0;
    };
    // too many key.branchIndices??
    Object.keys(key.branchIndices).forEach(resetBranchValue);
};

},{"./namespace":"chzFZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"chzFZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupTramOneSpace", ()=>setupTramOneSpace
);
parcelHelpers.export(exports, "buildNamespace", ()=>buildNamespace
);
const getTramWindow = ()=>{
    // if tram-one is setup it will have a defined value in the 'tram-space'
    const tramOneIsSetup = window['tram-space'];
    // otherwise, we should warn
    // this usually happens when calling a hook outside of a component function
    // but this could be potentially triggered other ways - if we find those, we should broaden the message then
    if (!tramOneIsSetup) throw new Error(`
			Tram-One: app has not started yet, but hook was called. Is it being invoked outside a component function?
			https://github.com/Tram-One/tram-one/issues/178
		`);
    return window;
};
const setupTramOneSpace = ()=>{
    window['tram-space'] = {
    };
};
const buildNamespace = (constructor)=>{
    const setup = (namespace)=>{
        const tramWindow = getTramWindow();
        tramWindow['tram-space'][namespace] = constructor();
        return tramWindow['tram-space'][namespace];
    };
    const get = (namespace)=>{
        const tramWindow = getTramWindow();
        return tramWindow['tram-space'][namespace];
    };
    const set = (namespace, value)=>{
        const tramWindow = getTramWindow();
        tramWindow['tram-space'][namespace] = value;
    };
    return {
        setup,
        get,
        set
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"1BjnD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodeNames = require("./node-names");
const { observe  } = require('@nx-js/observer-util');
// functions to go to nodes or indices (made for .map)
const toIndices = (node, index)=>index
;
// sorting function that prioritizes indices that are closest to a target
// e.g. target = 3, [1, 2, 3, 4, 5] => [3, 2, 4, 1, 5]
const byDistanceFromIndex = (targetIndex)=>(indexA, indexB)=>{
        const diffFromTargetA = Math.abs(indexA - targetIndex);
        const diffFromTargetB = Math.abs(indexB - targetIndex);
        return diffFromTargetA - diffFromTargetB;
    }
;
const hasMatchingTagName = (tagName)=>(node)=>{
        const nodeHasMatchingTagName = 'tagName' in node && node.tagName === tagName;
        // if the tagName matches, we want to process the node, otherwise skip it
        return nodeHasMatchingTagName ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
;
// get an array including the element and all it's children
const parentAndChildrenElements = (node, tagName)=>{
    const matchesTagName = hasMatchingTagName(tagName);
    const componentWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, matchesTagName);
    const parentAndChildren = [
        componentWalker.currentNode
    ];
    while(componentWalker.nextNode())parentAndChildren.push(componentWalker.currentNode);
    // since we are looking for elements (things with tagNames)
    // we can safely declare this as an array of Elements
    return parentAndChildren;
};
const defaultRemovedElementWithFocusData = {
    index: -1,
    tagName: '',
    scrollLeft: 0,
    scrollTop: 0,
    selectionStart: null,
    selectionEnd: null,
    selectionDirection: undefined
};
exports.default = (tagFunction)=>{
    let tagResult;
    const buildAndReplaceTag = ()=>{
        // if there is an existing tagResult, it is the last rendering, and so we want to re-render over it
        let oldTag = tagResult;
        let removedElementWithFocusData = defaultRemovedElementWithFocusData;
        // remove oldTag first so that we unobserve before we re-observe
        if (oldTag) {
            // we need to blow away any old focus data we had
            removedElementWithFocusData = defaultRemovedElementWithFocusData;
            // determine if this element (or any element under it) had focus
            const oldTagHasFocusedElement = oldTag.contains(document.activeElement);
            // if an element had focus, copy over all the selection data (so we can copy it back later)
            if (oldTagHasFocusedElement) {
                // we'll assume that the element is an HTMLInputElement, in reality other kinds of elements will be caught here,
                // but that's fine, since they have null as selection attributes, and setting them to null is fine
                const activeElement = document.activeElement;
                // first, we need to get all the elements that are similar (we'll use tagName)
                // this way, when we rerender, we can search for those tagNames, and just use the index we got here
                const allActiveLikeElements = parentAndChildrenElements(oldTag, activeElement.tagName);
                removedElementWithFocusData.index = allActiveLikeElements.findIndex((element)=>element === activeElement
                );
                // copy over the data
                removedElementWithFocusData.tagName = activeElement.tagName;
                removedElementWithFocusData.scrollLeft = activeElement.scrollLeft;
                removedElementWithFocusData.scrollTop = activeElement.scrollTop;
                removedElementWithFocusData.selectionStart = activeElement.selectionStart;
                removedElementWithFocusData.selectionEnd = activeElement.selectionEnd;
                removedElementWithFocusData.selectionDirection = activeElement.selectionDirection || undefined;
            }
            const emptyDiv = document.createElement('div');
            oldTag.replaceWith(emptyDiv);
            // copy the reaction and effects from the old tag to the empty div so we don't lose them
            emptyDiv[_nodeNames.TRAM_TAG_REACTION] = oldTag[_nodeNames.TRAM_TAG_REACTION];
            emptyDiv[_nodeNames.TRAM_TAG_NEW_EFFECTS] = oldTag[_nodeNames.TRAM_TAG_NEW_EFFECTS];
            emptyDiv[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS] = oldTag[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS];
            // set oldTag to emptyDiv, so we can replace it later
            oldTag = emptyDiv;
        }
        // build the component
        tagResult = tagFunction();
        // if oldTag was defined, then we need to replace it with the new result
        if (oldTag) {
            // if an element had focus, reapply it
            let elementToGiveFocus;
            if (removedElementWithFocusData.index >= 0) {
                const allActiveLikeElements = parentAndChildrenElements(tagResult, removedElementWithFocusData.tagName);
                // we'll look through the elements (in order of nodes closest to original index) and find a tag that matches.
                // this means if it didn't move, we'll get it right away,
                // if it did, we'll look at the elements closest to the original position
                const elementIndexToGiveFocus = allActiveLikeElements.map(toIndices).sort(byDistanceFromIndex(removedElementWithFocusData.index))[0];
                elementToGiveFocus = allActiveLikeElements[elementIndexToGiveFocus];
                // also try to set the selection, if there is a selection for this element
                if (elementToGiveFocus.setSelectionRange !== undefined) elementToGiveFocus.setSelectionRange(removedElementWithFocusData.selectionStart, removedElementWithFocusData.selectionEnd, removedElementWithFocusData.selectionDirection);
                elementToGiveFocus.scrollLeft = removedElementWithFocusData.scrollLeft;
                elementToGiveFocus.scrollTop = removedElementWithFocusData.scrollTop;
            }
            // copy the reaction and effects from the old tag to the new one
            tagResult[_nodeNames.TRAM_TAG_REACTION] = oldTag[_nodeNames.TRAM_TAG_REACTION];
            tagResult[_nodeNames.TRAM_TAG_NEW_EFFECTS] = oldTag[_nodeNames.TRAM_TAG_NEW_EFFECTS];
            tagResult[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS] = oldTag[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS];
            // both these actions cause forced reflow, and can be performance issues
            oldTag.replaceWith(tagResult);
            if (elementToGiveFocus && elementToGiveFocus.focus) elementToGiveFocus.focus();
        }
    };
    const tagReaction = observe(buildAndReplaceTag);
    // tagResult is always assigned as an artifact of the observe() call above
    // if it isn't, we want to know about it
    if (tagResult === undefined) throw new Error(`
			Tram-One: tagResult was not defined after building the tag.
			https://github.com/Tram-One/tram-one/issues/177
		`);
    // save the reaction to the node, so that the mutation-observer can unobserve it later
    tagResult[_nodeNames.TRAM_TAG_REACTION] = tagReaction;
    return tagResult;
};

},{"@nx-js/observer-util":"fjk4V","./node-names":"jE2wn","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"fjk4V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observe", ()=>observe
);
parcelHelpers.export(exports, "unobserve", ()=>unobserve
);
parcelHelpers.export(exports, "observable", ()=>observable
);
parcelHelpers.export(exports, "isObservable", ()=>isObservable
);
parcelHelpers.export(exports, "raw", ()=>raw
);
var connectionStore = new WeakMap();
var ITERATION_KEY = Symbol('iteration key');
function storeObservable(obj) {
    // this will be used to save (obj.key -> reaction) connections later
    connectionStore.set(obj, new Map());
}
function registerReactionForOperation(reaction, ref) {
    var target = ref.target;
    var key = ref.key;
    var type = ref.type;
    if (type === 'iterate') key = ITERATION_KEY;
    var reactionsForObj = connectionStore.get(target);
    var reactionsForKey = reactionsForObj.get(key);
    if (!reactionsForKey) {
        reactionsForKey = new Set();
        reactionsForObj.set(key, reactionsForKey);
    }
    // save the fact that the key is used by the reaction during its current run
    if (!reactionsForKey.has(reaction)) {
        reactionsForKey.add(reaction);
        reaction.cleaners.push(reactionsForKey);
    }
}
function getReactionsForOperation(ref) {
    var target = ref.target;
    var key = ref.key;
    var type = ref.type;
    var reactionsForTarget = connectionStore.get(target);
    var reactionsForKey = new Set();
    if (type === 'clear') reactionsForTarget.forEach(function(_, key) {
        addReactionsForKey(reactionsForKey, reactionsForTarget, key);
    });
    else addReactionsForKey(reactionsForKey, reactionsForTarget, key);
    if (type === 'add' || type === 'delete' || type === 'clear') {
        var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;
        addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);
    }
    return reactionsForKey;
}
function addReactionsForKey(reactionsForKey, reactionsForTarget, key) {
    var reactions = reactionsForTarget.get(key);
    reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);
}
function releaseReaction(reaction) {
    if (reaction.cleaners) reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);
    reaction.cleaners = [];
}
function releaseReactionKeyConnection(reactionsForKey) {
    reactionsForKey.delete(this);
}
// reactions can call each other and form a call stack
var reactionStack = [];
var isDebugging = false;
function runAsReaction(reaction, fn, context, args) {
    // do not build reactive relations, if the reaction is unobserved
    if (reaction.unobserved) return Reflect.apply(fn, context, args);
    // only run the reaction if it is not already in the reaction stack
    // TODO: improve this to allow explicitly recursive reactions
    if (reactionStack.indexOf(reaction) === -1) {
        // release the (obj -> key -> reactions) connections
        // and reset the cleaner connections
        releaseReaction(reaction);
        try {
            // set the reaction as the currently running one
            // this is required so that we can create (observable.prop -> reaction) pairs in the get trap
            reactionStack.push(reaction);
            return Reflect.apply(fn, context, args);
        } finally{
            // always remove the currently running flag from the reaction when it stops execution
            reactionStack.pop();
        }
    }
}
// register the currently running reaction to be queued again on obj.key mutations
function registerRunningReactionForOperation(operation) {
    // get the current reaction from the top of the stack
    var runningReaction = reactionStack[reactionStack.length - 1];
    if (runningReaction) {
        debugOperation(runningReaction, operation);
        registerReactionForOperation(runningReaction, operation);
    }
}
function queueReactionsForOperation(operation) {
    // iterate and queue every reaction, which is triggered by obj.key mutation
    getReactionsForOperation(operation).forEach(queueReaction, operation);
}
function queueReaction(reaction) {
    debugOperation(reaction, this);
    // queue the reaction for later execution or run it immediately
    if (typeof reaction.scheduler === 'function') reaction.scheduler(reaction);
    else if (typeof reaction.scheduler === 'object') reaction.scheduler.add(reaction);
    else reaction();
}
function debugOperation(reaction, operation) {
    if (reaction.debugger && !isDebugging) try {
        isDebugging = true;
        reaction.debugger(operation);
    } finally{
        isDebugging = false;
    }
}
function hasRunningReaction() {
    return reactionStack.length > 0;
}
var IS_REACTION = Symbol('is reaction');
function observe(fn, options) {
    if (options === void 0) options = {
    };
    // wrap the passed function in a reaction, if it is not already one
    var reaction = fn[IS_REACTION] ? fn : function reaction() {
        return runAsReaction(reaction, fn, this, arguments);
    };
    // save the scheduler and debugger on the reaction
    reaction.scheduler = options.scheduler;
    reaction.debugger = options.debugger;
    // save the fact that this is a reaction
    reaction[IS_REACTION] = true;
    // run the reaction once if it is not a lazy one
    if (!options.lazy) reaction();
    return reaction;
}
function unobserve(reaction) {
    // do nothing, if the reaction is already unobserved
    if (!reaction.unobserved) {
        // indicate that the reaction should not be triggered any more
        reaction.unobserved = true;
        // release (obj -> key -> reaction) connections
        releaseReaction(reaction);
    }
    // unschedule the reaction, if it is scheduled
    if (typeof reaction.scheduler === 'object') reaction.scheduler.delete(reaction);
}
var proxyToRaw = new WeakMap();
var rawToProxy = new WeakMap();
var hasOwnProperty = Object.prototype.hasOwnProperty;
function findObservable(obj) {
    var observableObj = rawToProxy.get(obj);
    if (hasRunningReaction() && typeof obj === 'object' && obj !== null) {
        if (observableObj) return observableObj;
        return observable(obj);
    }
    return observableObj || obj;
}
function patchIterator(iterator, isEntries) {
    var originalNext = iterator.next;
    iterator.next = function() {
        var ref = originalNext.call(iterator);
        var done = ref.done;
        var value = ref.value;
        if (!done) {
            if (isEntries) value[1] = findObservable(value[1]);
            else value = findObservable(value);
        }
        return {
            done: done,
            value: value
        };
    };
    return iterator;
}
var instrumentations = {
    has: function has(key) {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            key: key,
            type: 'has'
        });
        return proto.has.apply(target, arguments);
    },
    get: function get(key) {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            key: key,
            type: 'get'
        });
        return findObservable(proto.get.apply(target, arguments));
    },
    add: function add(key) {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        var hadKey = proto.has.call(target, key);
        // forward the operation before queueing reactions
        var result = proto.add.apply(target, arguments);
        if (!hadKey) queueReactionsForOperation({
            target: target,
            key: key,
            value: key,
            type: 'add'
        });
        return result;
    },
    set: function set(key, value) {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        var hadKey = proto.has.call(target, key);
        var oldValue = proto.get.call(target, key);
        // forward the operation before queueing reactions
        var result = proto.set.apply(target, arguments);
        if (!hadKey) queueReactionsForOperation({
            target: target,
            key: key,
            value: value,
            type: 'add'
        });
        else if (value !== oldValue) queueReactionsForOperation({
            target: target,
            key: key,
            value: value,
            oldValue: oldValue,
            type: 'set'
        });
        return result;
    },
    delete: function delete$1(key) {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        var hadKey = proto.has.call(target, key);
        var oldValue = proto.get ? proto.get.call(target, key) : undefined;
        // forward the operation before queueing reactions
        var result = proto.delete.apply(target, arguments);
        if (hadKey) queueReactionsForOperation({
            target: target,
            key: key,
            oldValue: oldValue,
            type: 'delete'
        });
        return result;
    },
    clear: function clear() {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        var hadItems = target.size !== 0;
        var oldTarget = target instanceof Map ? new Map(target) : new Set(target);
        // forward the operation before queueing reactions
        var result = proto.clear.apply(target, arguments);
        if (hadItems) queueReactionsForOperation({
            target: target,
            oldTarget: oldTarget,
            type: 'clear'
        });
        return result;
    },
    forEach: function forEach(cb) {
        var args = [], len = arguments.length - 1;
        while(len-- > 0)args[len] = arguments[len + 1];
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            type: 'iterate'
        });
        // swap out the raw values with their observable pairs
        // before passing them to the callback
        var wrappedCb = function(value) {
            var rest = [], len = arguments.length - 1;
            while(len-- > 0)rest[len] = arguments[len + 1];
            return cb.apply(void 0, [
                findObservable(value)
            ].concat(rest));
        };
        var ref;
        return (ref = proto.forEach).call.apply(ref, [
            target,
            wrappedCb
        ].concat(args));
    },
    keys: function keys() {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            type: 'iterate'
        });
        return proto.keys.apply(target, arguments);
    },
    values: function values() {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            type: 'iterate'
        });
        var iterator = proto.values.apply(target, arguments);
        return patchIterator(iterator, false);
    },
    entries: function entries() {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            type: 'iterate'
        });
        var iterator = proto.entries.apply(target, arguments);
        return patchIterator(iterator, true);
    },
    get size () {
        var target = proxyToRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        registerRunningReactionForOperation({
            target: target,
            type: 'iterate'
        });
        return Reflect.get(proto, 'size', target);
    }
};
instrumentations[Symbol.iterator] = function() {
    var target = proxyToRaw.get(this);
    var proto = Reflect.getPrototypeOf(this);
    registerRunningReactionForOperation({
        target: target,
        type: 'iterate'
    });
    var iterator = proto[Symbol.iterator].apply(target, arguments);
    return patchIterator(iterator, target instanceof Map);
};
var collectionHandlers = {
    get: function get(target, key, receiver) {
        // instrument methods and property accessors to be reactive
        target = hasOwnProperty.call(instrumentations, key) ? instrumentations : target;
        return Reflect.get(target, key, receiver);
    }
};
// eslint-disable-next-line
var globalObj = typeof window === 'object' ? window : Function('return this')();
// built-in object can not be wrapped by Proxies
// their methods expect the object instance as the 'this' instead of the Proxy wrapper
// complex objects are wrapped with a Proxy of instrumented methods
// which switch the proxy to the raw object and to add reactive wiring
var handlers = new Map([
    [
        Map,
        collectionHandlers
    ],
    [
        Set,
        collectionHandlers
    ],
    [
        WeakMap,
        collectionHandlers
    ],
    [
        WeakSet,
        collectionHandlers
    ],
    [
        Object,
        false
    ],
    [
        Array,
        false
    ],
    [
        Int8Array,
        false
    ],
    [
        Uint8Array,
        false
    ],
    [
        Uint8ClampedArray,
        false
    ],
    [
        Int16Array,
        false
    ],
    [
        Uint16Array,
        false
    ],
    [
        Int32Array,
        false
    ],
    [
        Uint32Array,
        false
    ],
    [
        Float32Array,
        false
    ],
    [
        Float64Array,
        false
    ]
]);
function shouldInstrument(ref) {
    var constructor = ref.constructor;
    var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;
    return !isBuiltIn || handlers.has(constructor);
}
function getHandlers(obj) {
    return handlers.get(obj.constructor);
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function(key) {
    return Symbol[key];
}).filter(function(value) {
    return typeof value === 'symbol';
}));
// intercept get operations on observables to know which reaction uses their properties
function get(target, key, receiver) {
    var result = Reflect.get(target, key, receiver);
    // do not register (observable.prop -> reaction) pairs for well known symbols
    // these symbols are frequently retrieved in low level JavaScript under the hood
    if (typeof key === 'symbol' && wellKnownSymbols.has(key)) return result;
    // register and save (observable.prop -> runningReaction)
    registerRunningReactionForOperation({
        target: target,
        key: key,
        receiver: receiver,
        type: 'get'
    });
    // if we are inside a reaction and observable.prop is an object wrap it in an observable too
    // this is needed to intercept property access on that object too (dynamic observable tree)
    var observableResult = rawToProxy.get(result);
    if (hasRunningReaction() && typeof result === 'object' && result !== null) {
        if (observableResult) return observableResult;
        // do not violate the none-configurable none-writable prop get handler invariant
        // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError
        var descriptor = Reflect.getOwnPropertyDescriptor(target, key);
        if (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) return observable(result);
    }
    // otherwise return the observable wrapper if it is already created and cached or the raw object
    return observableResult || result;
}
function has(target, key) {
    var result = Reflect.has(target, key);
    // register and save (observable.prop -> runningReaction)
    registerRunningReactionForOperation({
        target: target,
        key: key,
        type: 'has'
    });
    return result;
}
function ownKeys(target) {
    registerRunningReactionForOperation({
        target: target,
        type: 'iterate'
    });
    return Reflect.ownKeys(target);
}
// intercept set operations on observables to know when to trigger reactions
function set(target, key, value, receiver) {
    // make sure to do not pollute the raw object with observables
    if (typeof value === 'object' && value !== null) value = proxyToRaw.get(value) || value;
    // save if the object had a descriptor for this key
    var hadKey = hasOwnProperty$1.call(target, key);
    // save if the value changed because of this set operation
    var oldValue = target[key];
    // execute the set operation before running any reaction
    var result = Reflect.set(target, key, value, receiver);
    // do not queue reactions if the target of the operation is not the raw receiver
    // (possible because of prototypal inheritance)
    if (target !== proxyToRaw.get(receiver)) return result;
    // queue a reaction if it's a new property or its value changed
    if (!hadKey) queueReactionsForOperation({
        target: target,
        key: key,
        value: value,
        receiver: receiver,
        type: 'add'
    });
    else if (value !== oldValue) queueReactionsForOperation({
        target: target,
        key: key,
        value: value,
        oldValue: oldValue,
        receiver: receiver,
        type: 'set'
    });
    return result;
}
function deleteProperty(target, key) {
    // save if the object had the key
    var hadKey = hasOwnProperty$1.call(target, key);
    var oldValue = target[key];
    // execute the delete operation before running any reaction
    var result = Reflect.deleteProperty(target, key);
    // only queue reactions for delete operations which resulted in an actual change
    if (hadKey) queueReactionsForOperation({
        target: target,
        key: key,
        oldValue: oldValue,
        type: 'delete'
    });
    return result;
}
var baseHandlers = {
    get: get,
    has: has,
    ownKeys: ownKeys,
    set: set,
    deleteProperty: deleteProperty
};
function observable(obj) {
    if (obj === void 0) obj = {
    };
    // if it is already an observable or it should not be wrapped, return it
    if (proxyToRaw.has(obj) || !shouldInstrument(obj)) return obj;
    // if it already has a cached observable wrapper, return it
    // otherwise create a new observable
    return rawToProxy.get(obj) || createObservable(obj);
}
function createObservable(obj) {
    // if it is a complex built-in object or a normal object, wrap it
    var handlers = getHandlers(obj) || baseHandlers;
    var observable = new Proxy(obj, handlers);
    // save these to switch between the raw object and the wrapped object with ease later
    rawToProxy.set(obj, observable);
    proxyToRaw.set(observable, obj);
    // init basic data structures to save and cleanup later (observable.prop -> reaction) connections
    storeObservable(obj);
    return observable;
}
function isObservable(obj) {
    return proxyToRaw.has(obj);
}
function raw(obj) {
    return proxyToRaw.get(obj) || obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"jE2wn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TRAM_TAG", ()=>TRAM_TAG
);
parcelHelpers.export(exports, "TRAM_TAG_REACTION", ()=>TRAM_TAG_REACTION
);
parcelHelpers.export(exports, "TRAM_TAG_NEW_EFFECTS", ()=>TRAM_TAG_NEW_EFFECTS
);
parcelHelpers.export(exports, "TRAM_TAG_CLEANUP_EFFECTS", ()=>TRAM_TAG_CLEANUP_EFFECTS
);
const TRAM_TAG = 'tram-tag';
const TRAM_TAG_REACTION = 'tram-tag-reaction';
const TRAM_TAG_NEW_EFFECTS = 'tram-tag-new-effects';
const TRAM_TAG_CLEANUP_EFFECTS = 'tram-tag-cleanup-effects';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"djlQI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _engineNames = require("./engine-names");
var _nodeNames = require("./node-names");
var _effectStore = require("./effect-store");
exports.default = (tagFunction)=>{
    // save the existing effect queue for any components we are in the middle of building
    const existingQueuedEffects = {
        ..._effectStore.getEffectStore(_engineNames.TRAM_EFFECT_QUEUE)
    };
    // clear the effect queue (so we can listen for just new effects)
    _effectStore.clearEffectStore(_engineNames.TRAM_EFFECT_QUEUE);
    // create the component, which will save new effects to the effect queue
    const tagResult = tagFunction();
    // see if there are any brand new effects
    const existingEffects = _effectStore.getEffectStore(_engineNames.TRAM_EFFECT_STORE);
    const queuedEffects = _effectStore.getEffectStore(_engineNames.TRAM_EFFECT_QUEUE);
    // store new effects in the node we just built
    const newEffects = Object.keys(queuedEffects).filter((effect)=>!(effect in existingEffects)
    );
    tagResult[_nodeNames.TRAM_TAG_NEW_EFFECTS] = newEffects.map((newEffectKey)=>queuedEffects[newEffectKey]
    );
    // restore the effect queue to what it was before we started
    _effectStore.restoreEffectStore(_engineNames.TRAM_EFFECT_QUEUE, existingQueuedEffects);
    return tagResult;
};

},{"./engine-names":"bWqq3","./node-names":"jE2wn","./effect-store":"6tOoZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6tOoZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupEffectStore", ()=>setupEffectStore
);
parcelHelpers.export(exports, "getEffectStore", ()=>getEffectStore
);
parcelHelpers.export(exports, "setEffectStore", ()=>setEffectStore
);
parcelHelpers.export(exports, "clearEffectStore", ()=>clearEffectStore
);
parcelHelpers.export(exports, "restoreEffectStore", ()=>restoreEffectStore
);
/*
 * EffectStores in Tram-One are used for basic key-value object mappings that need
 * to be persisted in the globalSpace.
 *
 * Currently this is used with useEffect to keep track of what
 * new effects should be triggered or cleaned up
 */ var _namespace = require("./namespace");
const newDefaultEffectStore = ()=>{
    return {
    };
};
const { setup: setupEffectStore , get: getEffectStore , set: setEffectStore ,  } = _namespace.buildNamespace(newDefaultEffectStore);
const clearEffectStore = (effectName)=>{
    const effectStore = getEffectStore(effectName);
    Object.keys(effectStore).forEach((key)=>delete effectStore[key]
    );
};
const restoreEffectStore = setEffectStore;

},{"./namespace":"chzFZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"59Xs2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _engineNames = require("./engine-names");
var _effectStore = require("./effect-store");
var _workingKey = require("./working-key");
exports.default = (effect)=>{
    // get the store of effects
    const effectQueue = _effectStore.getEffectStore(_engineNames.TRAM_EFFECT_QUEUE);
    // get the key value from working-key
    const key = _workingKey.getWorkingKeyValue(_engineNames.TRAM_HOOK_KEY);
    // increment the working key branch value
    // this makes successive useEffects calls unique (until we reset the key)
    _workingKey.incrementWorkingKeyBranch(_engineNames.TRAM_HOOK_KEY);
    // append () so that it's easier to debug effects from components
    const callLikeKey = `${key}()`;
    // add the effect to the effect queue, so it can be processed later
    effectQueue[callLikeKey] = effect;
};

},{"./engine-names":"bWqq3","./effect-store":"6tOoZ","./working-key":"hOltX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bMUmG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _useStore = require("./use-store");
var _useStoreDefault = parcelHelpers.interopDefault(_useStore);
const urlListener = require('url-listener');
const useUrlParams = require('use-url-params');
exports.default = (pattern)=>{
    // save and update results in an observable, so that we can update
    // components and effects in a reactive way
    const initialParams = useUrlParams(pattern);
    const observedUrlParams = _useStoreDefault.default(initialParams);
    // urlListener can re-read the route and save the new results to the observable
    urlListener(()=>{
        const updatedParams = useUrlParams(pattern);
        // get all keys so we can override new and old ones (without having to override the whole object)
        const allParamKeys = [
            ...Object.keys(initialParams),
            ...Object.keys(updatedParams)
        ];
        allParamKeys.forEach((paramKey)=>{
            observedUrlParams[paramKey] = updatedParams[paramKey];
        });
    });
    return observedUrlParams;
};

},{"url-listener":"iiFTu","use-url-params":"cmhaZ","./use-store":"cZPHV","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"iiFTu":[function(require,module,exports) {
module.exports = (callback)=>{
    window.addEventListener('hashchange', callback, false);
    window.addEventListener('popstate', callback, false);
    const pushState = window.history.pushState;
    window.history.pushState = (state, ...args)=>{
        const returnValue = pushState.apply(history, [
            state
        ].concat(args));
        callback({
            state
        });
        return returnValue;
    };
};

},{}],"cZPHV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observableHook = require("./observable-hook");
var _observableHookDefault = parcelHelpers.interopDefault(_observableHook);
exports.default = (defaultValue)=>_observableHookDefault.default(undefined, defaultValue)
;

},{"./observable-hook":"bpySN","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bpySN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _engineNames = require("./engine-names");
var _observableStore = require("./observable-store");
var _workingKey = require("./working-key");
exports.default = (key, value)=>{
    const observableStore = _observableStore.getObservableStore(_engineNames.TRAM_OBSERVABLE_STORE);
    _workingKey.incrementWorkingKeyBranch(_engineNames.TRAM_HOOK_KEY);
    const resolvedKey = key || _workingKey.getWorkingKeyValue(_engineNames.TRAM_HOOK_KEY);
    if (!Object.prototype.hasOwnProperty.call(observableStore, resolvedKey) && value !== undefined) observableStore[resolvedKey] = Array.isArray(value) ? [
        ...value
    ] : {
        ...value
    };
    const keyValue = observableStore[resolvedKey];
    return keyValue;
};

},{"./engine-names":"bWqq3","./observable-store":"2Bjau","./working-key":"hOltX","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2Bjau":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupObservableStore", ()=>setupObservableStore
);
parcelHelpers.export(exports, "getObservableStore", ()=>getObservableStore
);
var _namespace = require("./namespace");
const { observable  } = require('@nx-js/observer-util');
const { setup: setupObservableStore , get: getObservableStore  } = _namespace.buildNamespace(()=>observable({
    })
);

},{"@nx-js/observer-util":"fjk4V","./namespace":"chzFZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bH0Nk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observableHook = require("./observable-hook");
var _observableHookDefault = parcelHelpers.interopDefault(_observableHook);
/** Implementation of the two function definitions */ function useGlobalStore(key, defaultValue) {
    return _observableHookDefault.default(key, defaultValue);
}
exports.default = useGlobalStore;

},{"./observable-hook":"bpySN","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"2PwLl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mount = require("./mount");
var _mountDefault = parcelHelpers.interopDefault(_mount);
var _buildMountingContainer = require("./build-mounting-container");
var _buildMountingContainerDefault = parcelHelpers.interopDefault(_buildMountingContainer);
var _engineNames = require("./engine-names");
var _namespace = require("./namespace");
var _effectStore = require("./effect-store");
var _workingKey = require("./working-key");
var _observableStore = require("./observable-store");
var _mutationObserver = require("./mutation-observer");
exports.default = (component, target)=>{
    /* setup all the internal engines required for tram-one to work */ // get the container to mount the app on
    const container = _buildMountingContainerDefault.default(target);
    _namespace.setupTramOneSpace();
    // setup store for effects
    _effectStore.setupEffectStore(_engineNames.TRAM_EFFECT_STORE);
    // setup queue for new effects when resolving mounts
    _effectStore.setupEffectStore(_engineNames.TRAM_EFFECT_QUEUE);
    // setup working key for hooks
    _workingKey.setupWorkingKey(_engineNames.TRAM_HOOK_KEY);
    // setup observable store for the useStore and useGlobalStore hooks
    _observableStore.setupObservableStore(_engineNames.TRAM_OBSERVABLE_STORE);
    // setup a mutation observer for cleaning up removed elements and triggering effects
    _mutationObserver.setupMutationObserver(_engineNames.TRAM_MUTATION_OBSERVER);
    // watch for changes on the target so that we can process node changes
    _mutationObserver.startWatcher(_engineNames.TRAM_MUTATION_OBSERVER, container);
    // trigger an initial mount
    _mountDefault.default(component, container);
};

},{"./mount":"cIpd8","./build-mounting-container":"bzgpU","./engine-names":"bWqq3","./namespace":"chzFZ","./effect-store":"6tOoZ","./working-key":"hOltX","./observable-store":"2Bjau","./mutation-observer":"bGRwU","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"cIpd8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _domWrappers = require("./dom-wrappers");
exports.default = (component, container)=>{
    const html = _domWrappers.registerHtml({
        app: component
    });
    // this sadly needs to be wrapped in some element so we can process effects
    // otherwise the root node will not have effects applied on it
    const renderedApp = html`<div><app /></div>`;
    container.replaceChild(renderedApp, container.firstElementChild);
};

},{"./dom-wrappers":"bABP7","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bzgpU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Helper function for getting an element when given a string or element
 * @param target either a CSS selector, or Element to attach the component to.
 * @returns the container that we can mount on
 */ const getContainerElement = (target)=>{
    // if the selector is a string, try to find the element,
    // otherwise it's probably DOM that we should write directly to
    if (typeof target === 'string') {
        const selectedElement = document.querySelector(target);
        if (selectedElement === null) throw new Error(`
				Tram-One: could not find target, is the element on the page yet?
				https://github.com/Tram-One/tram-one/issues/179
			`);
        return selectedElement;
    } else return target;
};
exports.default = (target)=>{
    const container = getContainerElement(target);
    // build a div to render the app on
    // - if it doesn't exist as a child of the selector, create one first
    if (!container.firstElementChild) {
        const containerChild = document.createElement('div');
        container.appendChild(containerChild);
    }
    return container;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"bGRwU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupMutationObserver", ()=>setupMutationObserver
);
parcelHelpers.export(exports, "getMutationObserver", ()=>getMutationObserver
);
parcelHelpers.export(exports, "startWatcher", ()=>startWatcher
);
var _nodeNames = require("./node-names");
var _namespace = require("./namespace");
/*
 * The mutation-observer is a global instance of browsers MutationObserver
 * which tracks when nodes are added or removed.
 *
 * When nodes are added we process their effects. When nodes are removed we process any cleanup,
 * and stop observers that would trigger for that node.
 */ const { observe , unobserve  } = require('@nx-js/observer-util');
// process new effects for new nodes
const processEffects = (node)=>{
    // if this element doesn't have new effects, it is not be a Tram-One Element
    if (!(_nodeNames.TRAM_TAG_NEW_EFFECTS in node)) return;
    const hasEffects = node[_nodeNames.TRAM_TAG_NEW_EFFECTS];
    if (hasEffects) {
        // create an array for the cleanup effects
        node[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS] = [];
        // run all the effects, saving any cleanup functions to the node
        node[_nodeNames.TRAM_TAG_NEW_EFFECTS].forEach((effect)=>{
            let cleanup;
            // this is called when an effect is re-triggered
            const effectReaction = observe(()=>{
                // verify that cleanup is a function before calling it (in case it was a promise)
                if (typeof cleanup === 'function') cleanup();
                cleanup = effect();
            });
            // this is called when a component with an effect is removed
            const totalCleanup = ()=>{
                // verify that cleanup is a function before calling it (in case it was a promise)
                if (typeof cleanup === 'function') cleanup();
                unobserve(effectReaction);
            };
            node[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS].push(totalCleanup);
        });
        // set new tag effects to an empty array
        node[_nodeNames.TRAM_TAG_NEW_EFFECTS] = [];
    }
};
// call all cleanup effects on the node
const cleanupEffects = (cleanupEffects)=>{
    cleanupEffects.forEach((cleanup)=>cleanup()
    );
};
// unobserve the reaction tied to the node, and run all cleanup effects for the node
const clearNode = (node)=>{
    // if this element doesn't have a Reaction, it is not a Tram-One Element
    if (!(_nodeNames.TRAM_TAG in node)) return;
    unobserve(node[_nodeNames.TRAM_TAG_REACTION]);
    cleanupEffects(node[_nodeNames.TRAM_TAG_CLEANUP_EFFECTS]);
};
const isTramOneComponent = (node)=>{
    // a node is a component if it has `TRAM_TAG` key on it
    const nodeIsATramOneComponent = _nodeNames.TRAM_TAG in node;
    // if it is a tram-one component, we want to process it, otherwise skip it
    return nodeIsATramOneComponent ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
};
// function to get the children (as a list) of the node passed in
// this only needs to query tram-one components, so we can use the attribute `tram`
const childrenComponents = (node)=>{
    const componentWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, isTramOneComponent);
    const children = [];
    while(componentWalker.nextNode())children.push(componentWalker.currentNode);
    return children;
};
const mutationObserverNamespaceConstructor = ()=>new MutationObserver((mutationList)=>{
        // cleanup orphaned nodes that are no longer on the DOM
        const removedNodesInMutation = (mutation)=>[
                ...mutation.removedNodes
            ]
        ;
        const removedNodes = mutationList.flatMap(removedNodesInMutation).flatMap(childrenComponents);
        removedNodes.forEach(clearNode);
        // call new effects on any new nodes
        const addedNodesInMutation = (mutation)=>[
                ...mutation.addedNodes
            ]
        ;
        const newNodes = mutationList.flatMap(addedNodesInMutation).flatMap(childrenComponents);
        newNodes.forEach(processEffects);
    })
;
const { setup: setupMutationObserver , get: getMutationObserver  } = _namespace.buildNamespace(mutationObserverNamespaceConstructor);
const startWatcher = (observerName, node)=>{
    const observerStore = getMutationObserver(observerName);
    observerStore.observe(node, {
        childList: true,
        subtree: true
    });
};

},{"@nx-js/observer-util":"fjk4V","./node-names":"jE2wn","./namespace":"chzFZ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"9DyTH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"5yNmg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const { registerHtml , useStore  } = require('../../src/tram-one');
const html = registerHtml();
exports.default = ()=>{
    const pageStore = useStore({
        queue: '1000',
        elements: '1000',
        startTimer: 0,
        endTimer: 0,
        renders: 0
    });
    const updateCount = (event)=>{
        pageStore.queue = event.target.value;
    };
    const render = ()=>{
        pageStore.renders++;
        pageStore.startTimer = performance.now();
        pageStore.elements = pageStore.queue;
        pageStore.endTimer = performance.now();
    };
    const numberOfElements = Number.parseInt(pageStore.elements, 10);
    const newSpan = ()=>html`<span>-</span>`
    ;
    const elements = [
        ...new Array(Number.isNaN(numberOfElements) ? 0 : numberOfElements)
    ].map(newSpan);
    return html`
		<section>
			<h1>Element Rendering Example</h1>
			<figure>Wait: ${pageStore.endTimer - pageStore.startTimer}</figure>
			<label for="element-count">Element Count</label>
			<input id="element-count" value=${pageStore.queue} onkeyup=${updateCount} />
			<button onclick=${render} renders=${pageStore.renders}>Render</button>
			<br />
			${elements}
		</section>
	`;
};

},{"../../src/tram-one":"3dkvQ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"gLVVv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _elementSwitcherSubSection = require("./element-switcher-sub-section");
var _elementSwitcherSubSectionDefault = parcelHelpers.interopDefault(_elementSwitcherSubSection);
var _elementSwitcherStore = require("./element-switcher-store");
var _elementSwitcherStoreDefault = parcelHelpers.interopDefault(_elementSwitcherStore);
const { registerHtml , useGlobalStore , useStore  } = require('../../src/tram-one');
const html = registerHtml({
    ElementSwitcher: _elementSwitcherSubSectionDefault.default,
    ElementStore: _elementSwitcherStoreDefault.default
});
exports.default = ()=>{
    const pageStore = useGlobalStore('STORE', {
        selected: 1
    });
    const switchStore = useStore({
        id: 0
    });
    const changeSelection = (newSelection)=>()=>{
            pageStore.selected = newSelection;
        }
    ;
    const startAutoSwitch = ()=>{
        switchStore.id = setInterval(()=>{
            (document.querySelector('nav button[selected] + button') || document.querySelector('nav button:first-of-type')).click();
        }, 500);
    };
    const stopAutoSwitch = ()=>{
        clearInterval(switchStore.id);
        switchStore.id = 0;
    };
    const cycle = switchStore.id ? html`<button onclick=${stopAutoSwitch}>Stop</button>` : html`<button onclick=${startAutoSwitch}>Cycle</button>`;
    const storeElements = [
        ...new Array(pageStore.selected)
    ].map(()=>{
        return html`<ElementStore />`;
    });
    return html`
		<section class="ElementSwitcher">
			<h1>Element Switching Example</h1>
			${cycle}
			<nav style="display: flex;">
				<button ${pageStore.selected === 1 ? 'selected' : ''} onclick=${changeSelection(1)}>1</button>
				<button ${pageStore.selected === 2 ? 'selected' : ''} onclick=${changeSelection(2)}>2</button>
				<button ${pageStore.selected === 3 ? 'selected' : ''} onclick=${changeSelection(3)}>3</button>
				<button ${pageStore.selected === 4 ? 'selected' : ''} onclick=${changeSelection(4)}>4</button>
				<button ${pageStore.selected === 5 ? 'selected' : ''} onclick=${changeSelection(5)}>5</button>
			</nav>
			${storeElements}
			<ElementSwitcher />
		</section>
	`;
};

},{"../../src/tram-one":"3dkvQ","./element-switcher-sub-section":"04mir","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV","./element-switcher-store":"6ro7V"}],"04mir":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const { registerHtml , useGlobalStore , useEffect  } = require('../../src/tram-one');
const html = registerHtml();
exports.default = ()=>{
    const pageStore = useGlobalStore('STORE');
    useEffect(()=>{
        document.title = pageStore.selected;
    });
    return html`
		<section class="ElementSwitcherSubSection">
			<span style="display: block;">${0 * pageStore.selected}</span>
			<span style="display: block;">${1 * pageStore.selected}</span>
			<span style="display: block;">${2 * pageStore.selected}</span>
			<span style="display: block;">${3 * pageStore.selected}</span>
			<span style="display: block;">${4 * pageStore.selected}</span>
			<span style="display: block;">${5 * pageStore.selected}</span>
			<span style="display: block;">${6 * pageStore.selected}</span>
			<span style="display: block;">${7 * pageStore.selected}</span>
			<span style="display: block;">${8 * pageStore.selected}</span>
			<span style="display: block;">${9 * pageStore.selected}</span>
			<span style="display: block;">${10 * pageStore.selected}</span>
			<span style="display: block;">${11 * pageStore.selected}</span>
			<span style="display: block;">${12 * pageStore.selected}</span>
			<span style="display: block;">${13 * pageStore.selected}</span>
			<span style="display: block;">${14 * pageStore.selected}</span>
			<span style="display: block;">${15 * pageStore.selected}</span>
		</section>
	`;
};

},{"../../src/tram-one":"3dkvQ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}],"6ro7V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const { registerHtml , useStore  } = require('../../src/tram-one');
const html = registerHtml();
exports.default = ()=>{
    const subElementStore = useStore({
        active: 1
    });
    return html` <span class="ElementSwitcherStore">${subElementStore.active},</span> `;
};

},{"../../src/tram-one":"3dkvQ","@parcel/transformer-js/src/esmodule-helpers.js":"ciiiV"}]},["6LJCz","4FN3P"], "4FN3P", "parcelRequire6f52")

//# sourceMappingURL=index.21b8d0fd.js.map
