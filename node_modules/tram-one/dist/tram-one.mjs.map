{"version":3,"file":"tram-one.mjs","sources":["../src/engine-names.ts","../src/namespace.ts","../src/working-key.ts","../src/node-names.ts","../src/observe-tag.ts","../src/effect-store.ts","../src/key-queue.ts","../src/process-hooks.ts","../src/dom.ts","../src/dom-wrappers.ts","../src/use-effect.ts","../src/observable-store.ts","../src/observable-hook.ts","../src/use-store.ts","../src/use-url-params.ts","../src/use-global-store.ts","../src/mount.ts","../src/build-mounting-container.ts","../src/key-store.ts","../src/mutation-observer.ts","../src/start.ts"],"sourcesContent":["/*\n * This file is a collection of strings used to store values\n * in the tram-one global space. If you ever need to debug Tram-One's\n * internal state, you can inspect these on the window.\n *\n * e.g. `window['tram-space']['tram-hook-key']`\n */\n\nexport const TRAM_HOOK_KEY = 'tram-hook-key';\nexport const TRAM_EFFECT_STORE = 'tram-effect-store';\nexport const TRAM_EFFECT_QUEUE = 'tram-effect-queue';\nexport const TRAM_KEY_STORE = 'tram-key-store';\nexport const TRAM_KEY_QUEUE = 'tram-key-queue';\nexport const TRAM_OBSERVABLE_STORE = 'tram-observable-store';\nexport const TRAM_MUTATION_OBSERVER = 'tram-mutation-observer';\n","/*\n * namespace is a generic interface for global tram-one state that needs\n * to be persisted in the app container. It exposes a setup and get function.\n */\n\nimport { TramWindow } from './types';\n\nconst getTramWindow = (): TramWindow => {\n\t// if tram-one is setup it will have a defined value in the 'tram-space'\n\tconst tramOneIsSetup = (window as unknown as TramWindow)['tram-space'];\n\n\t// otherwise, we should warn\n\t// this usually happens when calling a hook outside of a component function\n\t// but this could be potentially triggered other ways - if we find those, we should broaden the message then\n\tif (!tramOneIsSetup) {\n\t\tthrow new Error(`\n\t\t\tTram-One: app has not started yet, but hook was called. Is it being invoked outside a component function?\n\t\t\thttps://github.com/Tram-One/tram-one/issues/178\n\t\t`);\n\t}\n\n\treturn window as unknown as TramWindow;\n};\n\nexport const setupTramOneSpace = () => {\n\t(window as unknown as TramWindow)['tram-space'] = {};\n};\n\nexport const buildNamespace = <NamespaceStore>(constructor: () => NamespaceStore) => {\n\tconst setup = (namespace: string): NamespaceStore => {\n\t\tconst tramWindow = getTramWindow();\n\t\ttramWindow['tram-space'][namespace] = constructor();\n\t\treturn tramWindow['tram-space'][namespace];\n\t};\n\n\tconst get = (namespace: string): NamespaceStore => {\n\t\tconst tramWindow = getTramWindow();\n\t\treturn tramWindow['tram-space'][namespace];\n\t};\n\n\tconst set = (namespace: string, value: NamespaceStore) => {\n\t\tconst tramWindow = getTramWindow();\n\t\ttramWindow['tram-space'][namespace] = value;\n\t};\n\n\treturn { setup, get, set };\n};\n","import { buildNamespace } from './namespace';\nimport { WorkingkeyObject } from './types';\n\n/*\n * This file defines all the functions required to interact with\n * a working-key object. This working-key object is used to help\n * hooks understand where in the mounting process we are, and what\n * values or effects to pull / trigger.\n */\n\nconst defaultWorkingKey = () =>\n\t({\n\t\t// list of custom tags that we've stepped into\n\t\tbranch: [],\n\t\t// map of branches to index value (used as a cursor for hooks)\n\t\tbranchIndices: {\n\t\t\t'': 0,\n\t\t},\n\t} as WorkingkeyObject);\n\nexport const { setup: setupWorkingKey, get: getWorkingKey } = buildNamespace(defaultWorkingKey);\n\nconst getWorkingBranch = (keyName: string) => {\n\tconst workingkeyObject = getWorkingKey(keyName);\n\treturn workingkeyObject.branch.join('/');\n};\n\n/**\n * push a new branch value, usually when we step into a new\n * custom component when mounting.\n */\nexport const pushWorkingKeyBranch = (keyName: string, branch: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\tworkingKey.branch.push(branch);\n\tif (!workingKey.branchIndices[getWorkingBranch(keyName)]) {\n\t\tworkingKey.branchIndices[getWorkingBranch(keyName)] = 0;\n\t}\n};\n\n/**\n * pops the current branch value, usually when we are done mounting\n * a single child component.\n */\nexport const popWorkingKeyBranch = (keyName: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\tworkingKey.branch.pop();\n};\n\n/**\n * increments the value for the current branch.\n * These values are used to pull the correct hook value on re-renders.\n */\nexport const incrementWorkingKeyBranch = (keyName: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\tworkingKey.branchIndices[getWorkingBranch(keyName)] += 1;\n};\n\n/**\n * used to get a unique string that will be used as a key for observables and effects.\n * This unique string _should_ be consistent over many re-renders.\n */\nexport const getWorkingKeyValue = (keyName: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\n\tconst index = workingKey.branchIndices[getWorkingBranch(keyName)];\n\treturn `${getWorkingBranch(keyName)}[${index}]`;\n};\n\n/**\n * returns a deep copy of the existing key, usually used as a restore point later\n */\nexport const copyWorkingKey = (keyName: string) => {\n\tconst key = getWorkingKey(keyName);\n\treturn {\n\t\tbranch: [...key.branch],\n\t\tbranchIndices: { ...key.branchIndices },\n\t};\n};\n\n/**\n * if we needed to reset pre-emptively, use this to get back\n * to where the branches were before\n */\nexport const restoreWorkingKey = (keyName: string, restoreKey: WorkingkeyObject) => {\n\tconst key = getWorkingKey(keyName);\n\tconst branches = key.branchIndices;\n\n\tkey.branch = [...restoreKey.branch];\n\n\tconst resetBranchValue = (branch: string) => {\n\t\tbranches[branch] = restoreKey.branchIndices[branch] || 0;\n\t};\n\tObject.keys(key.branchIndices).forEach(resetBranchValue);\n};\n","/*\n * This file is a collection of strings used to store values\n * in custom elements. If you ever need to debug Tram-One's\n * internal state, you can inspect these on individual elements.\n *\n * e.g. `$0['tram-hook-key']`\n */\n\nexport const TRAM_TAG = 'tram-tag';\nexport const TRAM_TAG_REACTION = 'tram-tag-reaction';\nexport const TRAM_TAG_STORE_KEYS = 'tram-tag-store-keys';\nexport const TRAM_TAG_NEW_EFFECTS = 'tram-tag-new-effects';\nexport const TRAM_TAG_CLEANUP_EFFECTS = 'tram-tag-cleanup-effects';\n","const { observe } = require('@nx-js/observer-util');\n\nimport { TRAM_TAG_REACTION, TRAM_TAG_NEW_EFFECTS, TRAM_TAG_CLEANUP_EFFECTS, TRAM_TAG } from './node-names';\nimport { TramOneElement, RemovedElementDataStore, Reaction, ElementPotentiallyWithSelectionAndFocus } from './types';\n\n// functions to go to nodes or indices (made for .map)\nconst toIndices = (node: Node, index: number) => index;\n\n// sorting function that prioritizes indices that are closest to a target\n// e.g. target = 3, [1, 2, 3, 4, 5] => [3, 2, 4, 1, 5]\nconst byDistanceFromIndex = (targetIndex: number) => (indexA: number, indexB: number) => {\n\tconst diffFromTargetA = Math.abs(indexA - targetIndex);\n\tconst diffFromTargetB = Math.abs(indexB - targetIndex);\n\treturn diffFromTargetA - diffFromTargetB;\n};\n\nconst hasMatchingTagName = (tagName: string) => (node: Node | Element) => {\n\tconst nodeHasMatchingTagName = 'tagName' in node && node.tagName === tagName;\n\t// if the tagName matches, we want to process the node, otherwise skip it\n\treturn nodeHasMatchingTagName ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n};\n\n// get an array including the element and all it's children\nconst parentAndChildrenElements = (node: Element, tagName: string) => {\n\tconst matchesTagName = hasMatchingTagName(tagName);\n\tconst componentWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, matchesTagName);\n\tconst parentAndChildren = [componentWalker.currentNode];\n\twhile (componentWalker.nextNode()) {\n\t\tparentAndChildren.push(componentWalker.currentNode);\n\t}\n\n\t// since we are looking for elements (things with tagNames)\n\t// we can safely declare this as an array of Elements\n\treturn parentAndChildren as Element[];\n};\n\nconst defaultRemovedElementWithFocusData: RemovedElementDataStore = {\n\tindex: -1,\n\ttagName: '',\n\tscrollLeft: 0,\n\tscrollTop: 0,\n\tselectionStart: null,\n\tselectionEnd: null,\n\tselectionDirection: undefined,\n};\n\n/**\n * This is a helper function for the dom creation.\n * This function observes any state values used when making the tag, and allow it to update\n * independently when one of those state values updates.\n *\n * The mutation-observer will unobserve any reactions here when the node is removed.\n *\n * The parameter tagFunction is almost a TramOneComponent, but it already has the props and children prepopulated,\n * and so has no parameters, but returns a TramOneElement\n */\nexport default (tagFunction: () => TramOneElement): TramOneElement => {\n\tlet tagResult: TramOneElement | undefined;\n\tconst buildAndReplaceTag = () => {\n\t\t// if there is an existing tagResult, it is the last rendering, and so we want to re-render over it\n\t\tlet oldTag = tagResult;\n\t\tlet removedElementWithFocusData = defaultRemovedElementWithFocusData;\n\n\t\t// remove oldTag first so that we unobserve before we re-observe\n\t\tif (oldTag) {\n\t\t\t// we need to blow away any old focus data we had\n\t\t\tremovedElementWithFocusData = defaultRemovedElementWithFocusData;\n\n\t\t\t// determine if this element (or any element under it) had focus\n\t\t\tconst oldTagHasFocusedElement = oldTag.contains(document.activeElement);\n\n\t\t\t// if an element had focus, copy over all the selection data (so we can copy it back later)\n\t\t\tif (oldTagHasFocusedElement) {\n\t\t\t\t// we'll assume that the element is an HTMLInputElement, in reality other kinds of elements will be caught here,\n\t\t\t\t// but that's fine, since they have null as selection attributes, and setting them to null is fine\n\t\t\t\tconst activeElement = document.activeElement as HTMLInputElement;\n\n\t\t\t\t// first, we need to get all the elements that are similar (we'll use tagName)\n\t\t\t\t// this way, when we rerender, we can search for those tagNames, and just use the index we got here\n\t\t\t\tconst allActiveLikeElements = parentAndChildrenElements(oldTag, activeElement.tagName);\n\t\t\t\tremovedElementWithFocusData.index = allActiveLikeElements.findIndex((element) => element === activeElement);\n\n\t\t\t\t// copy over the data\n\t\t\t\tremovedElementWithFocusData.tagName = activeElement.tagName;\n\t\t\t\tremovedElementWithFocusData.scrollLeft = activeElement.scrollLeft;\n\t\t\t\tremovedElementWithFocusData.scrollTop = activeElement.scrollTop;\n\t\t\t\tremovedElementWithFocusData.selectionStart = activeElement.selectionStart;\n\t\t\t\tremovedElementWithFocusData.selectionEnd = activeElement.selectionEnd;\n\t\t\t\tremovedElementWithFocusData.selectionDirection = activeElement.selectionDirection || undefined;\n\t\t\t}\n\n\t\t\tconst emptyDiv = document.createElement('div') as unknown as TramOneElement;\n\t\t\toldTag.replaceWith(emptyDiv);\n\n\t\t\t// copy the reaction and effects from the old tag to the empty div so we don't lose them\n\t\t\temptyDiv[TRAM_TAG_REACTION] = oldTag[TRAM_TAG_REACTION];\n\t\t\temptyDiv[TRAM_TAG_NEW_EFFECTS] = oldTag[TRAM_TAG_NEW_EFFECTS];\n\t\t\temptyDiv[TRAM_TAG_CLEANUP_EFFECTS] = oldTag[TRAM_TAG_CLEANUP_EFFECTS];\n\n\t\t\t// set oldTag to emptyDiv, so we can replace it later\n\t\t\toldTag = emptyDiv;\n\t\t}\n\n\t\t// build the component\n\t\ttagResult = tagFunction();\n\n\t\t// if oldTag was defined, then we need to replace it with the new result\n\t\tif (oldTag) {\n\t\t\t// if an element had focus, reapply it\n\t\t\tlet elementToGiveFocus;\n\t\t\tif (removedElementWithFocusData.index >= 0) {\n\t\t\t\tconst allActiveLikeElements = parentAndChildrenElements(tagResult, removedElementWithFocusData.tagName);\n\n\t\t\t\t// we'll look through the elements (in order of nodes closest to original index) and find a tag that matches.\n\t\t\t\t// this means if it didn't move, we'll get it right away,\n\t\t\t\t// if it did, we'll look at the elements closest to the original position\n\t\t\t\tconst elementIndexToGiveFocus = allActiveLikeElements\n\t\t\t\t\t.map(toIndices)\n\t\t\t\t\t.sort(byDistanceFromIndex(removedElementWithFocusData.index))[0];\n\n\t\t\t\telementToGiveFocus = allActiveLikeElements[elementIndexToGiveFocus] as ElementPotentiallyWithSelectionAndFocus;\n\t\t\t\t// also try to set the selection, if there is a selection for this element\n\t\t\t\ttry {\n\t\t\t\t\tif (elementToGiveFocus.setSelectionRange !== undefined) {\n\t\t\t\t\t\telementToGiveFocus.setSelectionRange(\n\t\t\t\t\t\t\tremovedElementWithFocusData.selectionStart,\n\t\t\t\t\t\t\tremovedElementWithFocusData.selectionEnd,\n\t\t\t\t\t\t\tremovedElementWithFocusData.selectionDirection\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (exception) {\n\t\t\t\t\t// don't worry if we fail\n\t\t\t\t\t// this can happen if the element has a `setSelectionRange` but it isn't supported\n\t\t\t\t\t// e.g. input with type=\"range\"\n\t\t\t\t}\n\n\t\t\t\telementToGiveFocus.scrollLeft = removedElementWithFocusData.scrollLeft;\n\t\t\t\telementToGiveFocus.scrollTop = removedElementWithFocusData.scrollTop;\n\t\t\t}\n\n\t\t\t// don't lose track that this is still a tram-one element\n\t\t\ttagResult[TRAM_TAG] = true;\n\n\t\t\t// copy the reaction and effects from the old tag to the new one\n\t\t\ttagResult[TRAM_TAG_REACTION] = oldTag[TRAM_TAG_REACTION];\n\t\t\ttagResult[TRAM_TAG_NEW_EFFECTS] = oldTag[TRAM_TAG_NEW_EFFECTS];\n\t\t\ttagResult[TRAM_TAG_CLEANUP_EFFECTS] = oldTag[TRAM_TAG_CLEANUP_EFFECTS];\n\n\t\t\t// both these actions cause forced reflow, and can be performance issues\n\t\t\toldTag.replaceWith(tagResult);\n\t\t\tif (elementToGiveFocus && elementToGiveFocus.focus) elementToGiveFocus.focus();\n\t\t}\n\t};\n\n\tconst tagReaction = observe(buildAndReplaceTag) as Reaction;\n\n\t// tagResult is always assigned as an artifact of the observe() call above\n\t// if it isn't, we want to know about it\n\tif (tagResult === undefined) {\n\t\tthrow new Error(`\n\t\t\tTram-One: tagResult was not defined after building the tag.\n\t\t\thttps://github.com/Tram-One/tram-one/issues/177\n\t\t`);\n\t}\n\n\t// save the reaction to the node, so that the mutation-observer can unobserve it later\n\ttagResult[TRAM_TAG_REACTION] = tagReaction;\n\n\treturn tagResult;\n};\n","/*\n * EffectStores in Tram-One are used for basic key-value object mappings that need\n * to be persisted in the globalSpace.\n *\n * Currently this is used with useEffect to keep track of what\n * new effects should be triggered or cleaned up\n */\n\nimport { buildNamespace } from './namespace';\nimport { EffectStore } from './types';\n\nconst newDefaultEffectStore = () => {\n\treturn {} as EffectStore;\n};\n\nexport const {\n\tsetup: setupEffectStore,\n\tget: getEffectStore,\n\tset: setEffectStore,\n} = buildNamespace(newDefaultEffectStore);\n\n/**\n * clear the effect store\n * usually called when we want to empty the effect store\n */\nexport const clearEffectStore = (effectStoreName: string) => {\n\tconst effectStore = getEffectStore(effectStoreName);\n\n\tObject.keys(effectStore).forEach((key) => delete effectStore[key]);\n};\n\n/**\n * restore the effect store to a previous value\n * usually used when we had to interrupt the processing of effects\n */\nexport const restoreEffectStore = setEffectStore;\n","/*\n * The KeyQueue in Tram-One is a basic list of keys\n * that needs to be persisted in the globalSpace.\n *\n * Currently this is used with useStore to keep track of what\n * stores need to be associated with generated elements\n */\n\nimport { buildNamespace } from './namespace';\n\nconst newDefaultKeyQueue = () => {\n\treturn [] as string[];\n};\n\nexport const { setup: setupKeyQueue, get: getKeyQueue, set: setKeyQueue } = buildNamespace(newDefaultKeyQueue);\n\n/**\n * clear the key queue\n * usually called when we want to empty the key queue\n */\nexport const clearKeyQueue = (keyQueueName: string) => {\n\tconst keyQueue = getKeyQueue(keyQueueName);\n\n\tkeyQueue.splice(0, keyQueue.length);\n};\n\n/**\n * restore the key queue to a previous value\n * usually used when we had to interrupt the processing of keys\n */\nexport const restoreKeyQueue = setKeyQueue;\n","import { TRAM_EFFECT_STORE, TRAM_EFFECT_QUEUE, TRAM_KEY_QUEUE } from './engine-names';\nimport { TRAM_TAG_NEW_EFFECTS, TRAM_TAG_STORE_KEYS } from './node-names';\nimport { getEffectStore, clearEffectStore, restoreEffectStore } from './effect-store';\nimport { TramOneElement } from './types';\nimport { clearKeyQueue, getKeyQueue, restoreKeyQueue } from './key-queue';\n\n/**\n * This is a helper function for the dom creation.\n * This function stores any keys generated when building a tag in the resulting node that is generated.\n *\n * These are later processed by the mutation-observer, and cleaned up when the node is removed by the mutation-observer.\n *\n * This function is called every time state changes in an observable store\n */\nexport default (tagFunction: () => TramOneElement) => {\n\t// save the existing effect queue and key queue for any components we are in the middle of building\n\tconst existingQueuedEffects = { ...getEffectStore(TRAM_EFFECT_QUEUE) };\n\tconst existingQueuedKeys = [...getKeyQueue(TRAM_KEY_QUEUE)];\n\n\t// clear the queues (so we can get just new effects and keys)\n\tclearEffectStore(TRAM_EFFECT_QUEUE);\n\tclearKeyQueue(TRAM_KEY_QUEUE);\n\n\t// create the component, which will save new effects to the effect queue\n\tconst tagResult = tagFunction();\n\n\t// see if there are any brand new effects\n\tconst existingEffects = getEffectStore(TRAM_EFFECT_STORE);\n\tconst queuedEffects = getEffectStore(TRAM_EFFECT_QUEUE);\n\n\t// get all new keys\n\tconst newKeys = getKeyQueue(TRAM_KEY_QUEUE);\n\n\t// store new effects in the node we just built\n\tconst newEffects = Object.keys(queuedEffects).filter((effect) => !(effect in existingEffects));\n\ttagResult[TRAM_TAG_NEW_EFFECTS] = newEffects.map((newEffectKey) => queuedEffects[newEffectKey]);\n\n\t// store keys in the node we just built\n\ttagResult[TRAM_TAG_STORE_KEYS] = newKeys;\n\n\t// restore the effect and key queues to what they were before we started\n\trestoreEffectStore(TRAM_EFFECT_QUEUE, existingQueuedEffects);\n\trestoreKeyQueue(TRAM_KEY_QUEUE, existingQueuedKeys);\n\n\treturn tagResult;\n};\n","const nanohtml = require('@tram-one/nanohtml');\nconst rbel = require('@tram-one/rbel');\nconst hyperx = require('@tram-one/hyperx');\n\nimport { TRAM_HOOK_KEY } from './engine-names';\nimport {\n\tpushWorkingKeyBranch,\n\tpopWorkingKeyBranch,\n\tincrementWorkingKeyBranch,\n\tcopyWorkingKey,\n\trestoreWorkingKey,\n} from './working-key';\nimport observeTag from './observe-tag';\nimport processHooks from './process-hooks';\nimport { TRAM_TAG, TRAM_TAG_NEW_EFFECTS, TRAM_TAG_CLEANUP_EFFECTS } from './node-names';\n\nimport { Registry, Props, DOMTaggedTemplateFunction } from './types';\n\n/**\n * This function takes in a namespace and registry of custom components,\n * and builds a `dom` template tag function that can take in a template XML string.\n *\n * This function shouldn't need to be called directly, instead, you can use `registerHtml` or `registerSvg`\n *\n * @param registry mapping of tag names to component functions\n * @param namespace namespace to create nodes in (by default XHTML namespace)\n */\nexport const registerDom = (namespace: string | null, registry: Registry = {}): DOMTaggedTemplateFunction => {\n\t// modify the registry so that each component function updates the hook working key\n\tconst hookedRegistry = Object.keys(registry).reduce((newRegistry, tagName) => {\n\t\tconst tagFunction = registry[tagName];\n\t\tconst hookedTagFunction = (props: Props, children: Element) => {\n\t\t\t// push a new branch onto the working key so any values that need to be unique among components\n\t\t\t// but consistent across renders can be read\n\t\t\tconst stringifiedProps = JSON.stringify(props);\n\t\t\tconst newBranch = `${tagName}[${stringifiedProps}]`;\n\t\t\tpushWorkingKeyBranch(TRAM_HOOK_KEY, newBranch);\n\n\t\t\t// increment branch so that we have a unique value (in case we are rendering a list of components)\n\t\t\tincrementWorkingKeyBranch(TRAM_HOOK_KEY);\n\t\t\tconst uniqueBranch = copyWorkingKey(TRAM_HOOK_KEY);\n\n\t\t\t// create a tag function that has the args passed in\n\t\t\tconst populatedTagFunction = () => {\n\t\t\t\t// reset working key so we have the correct place when starting a new component\n\t\t\t\trestoreWorkingKey(TRAM_HOOK_KEY, uniqueBranch);\n\n\t\t\t\treturn tagFunction(props, children);\n\t\t\t};\n\n\t\t\t// observe store usage and process any new effects that were called when building the component\n\t\t\tconst processHooksAndBuildTagResult = () => processHooks(populatedTagFunction);\n\t\t\tconst tagResult = observeTag(processHooksAndBuildTagResult);\n\n\t\t\t// pop the branch off (since we are done rendering this component)\n\t\t\tpopWorkingKeyBranch(TRAM_HOOK_KEY);\n\n\t\t\t// decorate the properties expected on TramOneElements (see node-names.ts)\n\t\t\ttagResult[TRAM_TAG] = true;\n\t\t\t// we won't decorate TRAM_TAG_REACTION, that needs to be done later when we observe the tag\n\t\t\ttagResult[TRAM_TAG_NEW_EFFECTS] = tagResult[TRAM_TAG_NEW_EFFECTS] || [];\n\t\t\ttagResult[TRAM_TAG_CLEANUP_EFFECTS] = tagResult[TRAM_TAG_NEW_EFFECTS] || [];\n\n\t\t\treturn tagResult;\n\t\t};\n\n\t\treturn { ...newRegistry, [tagName]: hookedTagFunction };\n\t}, {});\n\n\treturn rbel(hyperx, nanohtml(namespace), hookedRegistry);\n};\n","import { registerDom } from './dom';\n\nimport { Registry } from './types';\n\n/**\n * @name registerHtml\n * @link https://tram-one.io/#register-html\n * @description\n * Function to generate a tagged template function for XHTML / HTML.\n * Takes in a registry that allows you to import other tag functions and use them in your template string.\n *\n * @param registry map of tag names to functions, use this to use custom elements built in tram-one\n * @return tagged template function that builds HTML components\n */\nexport const registerHtml = (registry?: Registry) => {\n\treturn registerDom(null, registry);\n};\n\n/**\n * @name registerSvg\n * @link https://tram-one.io/#register-svg\n * @description\n * Function to generate a tagged template function for SVG.\n *\n * @param registry map of tag names to functions, use this to use custom elements built in tram-one\n * @return tagged template function that builds SVG components\n */\nexport const registerSvg = (registry?: Registry) => {\n\treturn registerDom('http://www.w3.org/2000/svg', registry);\n};\n","import { TRAM_HOOK_KEY, TRAM_EFFECT_QUEUE } from './engine-names';\nimport { getEffectStore } from './effect-store';\nimport { getWorkingKeyValue, incrementWorkingKeyBranch } from './working-key';\n\nimport { Effect } from './types';\n\n/**\n * @name useEffect\n * @link https://tram-one.io/#use-effect\n * @description\n * Hook that triggers component start, update, and cleanup effects.\n * If the return of effect is another function, then that function is called on when the component is removed.\n * If the effect is dependent on a observable, it will automatically trigger again if that value updates.\n *\n * @param effect function to run on component mount\n */\nexport default (effect: Effect): void => {\n\t// get the store of effects\n\tconst effectQueue = getEffectStore(TRAM_EFFECT_QUEUE);\n\n\t// get the key value from working-key\n\tconst key = getWorkingKeyValue(TRAM_HOOK_KEY);\n\n\t// increment the working key branch value\n\t// this makes successive useEffects calls unique (until we reset the key)\n\tincrementWorkingKeyBranch(TRAM_HOOK_KEY);\n\n\t// append () so that it's easier to debug effects from components\n\tconst callLikeKey = `${key}()`;\n\n\t// add the effect to the effect queue, so it can be processed later\n\teffectQueue[callLikeKey] = effect;\n};\n","const { observable } = require('@nx-js/observer-util');\n\nimport { buildNamespace } from './namespace';\n\n/*\n * Observable Stores in Tram-One are used for objects whose properties need to be observed.\n * This stores the values in the useStore and useGlobalStore hooks, internally tracking\n * them as proxies, and making observed functions respond to their changes.\n */\n\nexport const { setup: setupObservableStore, get: getObservableStore } = buildNamespace(() => observable({}));\n","import { TRAM_OBSERVABLE_STORE, TRAM_HOOK_KEY, TRAM_KEY_QUEUE } from './engine-names';\nimport { getObservableStore } from './observable-store';\nimport { getWorkingKeyValue, incrementWorkingKeyBranch } from './working-key';\n\nimport { StoreObject } from './types';\nimport { getKeyQueue } from './key-queue';\n\n/**\n * Shared source code for both observable hooks, useStore, and useGlobalStore.\n * This hook exposes a globally stored value (in either case), that can cause the component\n * to update when a subfield of that value is updated.\n *\n * It has a similar interface to React's useState\n */\nexport default <Store extends StoreObject>(key?: string, value?: Store): Store => {\n\t// get the store of effects\n\tconst observableStore = getObservableStore(TRAM_OBSERVABLE_STORE);\n\n\t// increment the working key branch value\n\t// this makes successive hooks unique (until we reset the key)\n\tincrementWorkingKeyBranch(TRAM_HOOK_KEY);\n\n\t// if a key was passed in, use that, otherwise, generate a key\n\tconst resolvedKey = key || getWorkingKeyValue(TRAM_HOOK_KEY);\n\n\t// saves value into the store if it doesn't exist in the observableStore yet\n\t// and if the value we are writing is defined\n\tif (!Object.prototype.hasOwnProperty.call(observableStore, resolvedKey) && value !== undefined) {\n\t\t// save the value as a shallow copy of the parameter passed in\n\t\tobservableStore[resolvedKey] = Array.isArray(value) ? [...value] : { ...value };\n\t}\n\n\t// get value for key\n\tconst keyValue = observableStore[resolvedKey];\n\n\t// if we weren't passed in a key, this is a local obserable (not global),\n\tconst isLocalStore = !key;\n\tif (isLocalStore) {\n\t\t// if this is local, we should associate it with the element by putting it in the keyQueue\n\t\tgetKeyQueue(TRAM_KEY_QUEUE).push(resolvedKey);\n\t}\n\n\t// return value\n\treturn keyValue;\n};\n","import observableHook from './observable-hook';\n\nimport { StoreObject } from './types';\n\n/**\n * @name useStore\n * @link https://tram-one.io/#use-store\n * @description\n * Hook that stores local component state.\n *\n * If the subfield of an object, or element of an array is updated\n * it will cause only the components that are dependent on that value to update.\n *\n * @param defaultValue the default value to start the store at\n *\n * @returns the store to interact with.\n */\nexport default <Store extends StoreObject>(defaultValue: Store) => observableHook(undefined, defaultValue);\n","const urlListener = require('url-listener');\nconst useUrlParams = require('use-url-params');\n\nimport useStore from './use-store';\nimport { UrlMatchResults } from './types';\n\n/**\n * @name useUrlParams\n * @link https://tram-one.io/#use-url-params\n * @description\n * Hook that returns path variables based on the route.\n * Can return path parameters, query params, and more.\n * It's internal functionality is powered by the package\n * {@link https://www.npmjs.com/package/rlite-router rlite}\n *\n * @param pattern path to match on (can include path variables)\n *\n * @returns object with a `matches` key, and (if it matched) path and query parameters\n */\nexport default (pattern: string): UrlMatchResults => {\n\t// save and update results in an observable, so that we can update\n\t// components and effects in a reactive way\n\tconst initialParams = useUrlParams(pattern) as UrlMatchResults;\n\tconst observedUrlParams = useStore(initialParams);\n\n\t// urlListener can re-read the route and save the new results to the observable\n\turlListener(() => {\n\t\tconst updatedParams = useUrlParams(pattern);\n\n\t\t// get all keys so we can override new and old ones (without having to override the whole object)\n\t\tconst allParamKeys = [...Object.keys(initialParams), ...Object.keys(updatedParams)];\n\t\tallParamKeys.forEach((paramKey) => {\n\t\t\tobservedUrlParams[paramKey] = updatedParams[paramKey];\n\t\t});\n\t});\n\n\treturn observedUrlParams;\n};\n","import observableHook from './observable-hook';\n\nimport { StoreObject } from './types';\n\n/**\n * @name useGlobalObservable\n * @link https://tram-one.io/#use-global-observable\n * @description\n * Hook that stores global state and makes it accessible in the entire app.\n *\n * If the subfield of an object, or element of an array is updated\n * it will cause only the components that are dependent on that value to update.\n *\n * @param key a unique string to write and read the global value\n * @param defaultValue the default value to start the store at\n *\n * @returns the store to interact with.\n */\nfunction useGlobalStore<Store extends StoreObject>(key: string, defaultValue: Store): Store;\n/**\n * @name useGlobalObservable\n * @link https://tram-one.io/#use-global-observable\n * @description\n * Hook that stores global state and makes it accessible in the entire app.\n *\n * If the subfield of an object, or element of an array is updated\n * it will cause only the components that are dependent on that value to update.\n *\n * @param key a unique string to write and read the global value\n *\n * @returns the store to interact with.\n */\nfunction useGlobalStore(key: string): unknown;\n/** Implementation of the two function definitions */\nfunction useGlobalStore(key: string, defaultValue?: StoreObject): any {\n\treturn observableHook(key, defaultValue);\n}\n\nexport default useGlobalStore;\n","import { registerHtml } from './dom-wrappers';\nimport { Container, TramOneComponent } from './types';\n\n/**\n * Updates a container with an initial component for the first render.\n * @param component the tram-one component to render\n * @param container an element to render the component on\n */\nexport default (component: TramOneComponent, container: Container) => {\n\tconst html = registerHtml({\n\t\tapp: component,\n\t});\n\n\t// this sadly needs to be wrapped in some element so we can process effects\n\t// otherwise the root node will not have effects applied on it\n\tconst renderedApp = html`<div><app /></div>`;\n\tcontainer.replaceChild(renderedApp, container.firstElementChild);\n};\n","import { Container, ElementOrSelector } from './types';\n\n/**\n * Helper function for getting an element when given a string or element\n * @param target either a CSS selector, or Element to attach the component to.\n * @returns the container that we can mount on\n */\nconst getContainerElement = (target: ElementOrSelector): Element => {\n\t// if the selector is a string, try to find the element,\n\t// otherwise it's probably DOM that we should write directly to\n\tif (typeof target === 'string') {\n\t\tconst selectedElement = document.querySelector(target);\n\t\tif (selectedElement === null) {\n\t\t\tthrow new Error(`\n\t\t\t\tTram-One: could not find target, is the element on the page yet?\n\t\t\t\thttps://github.com/Tram-One/tram-one/issues/179\n\t\t\t`);\n\t\t}\n\t\treturn selectedElement;\n\t} else {\n\t\treturn target;\n\t}\n};\n\n/**\n * Function to determine (or create) the element that we will mount our tram-one app onto\n * @param target either a CSS selector, or Element to attach the component to.\n * This elememnt should be initially empty.\n *\n * @returns the container, now with a div that tram-one can manage\n */\nexport default (target: ElementOrSelector): Container => {\n\tconst container = getContainerElement(target);\n\n\t// build a div to render the app on\n\t// - if it doesn't exist as a child of the selector, create one first\n\tif (!container.firstElementChild) {\n\t\tconst containerChild = document.createElement('div');\n\t\tcontainer.appendChild(containerChild);\n\t}\n\n\treturn container as Container;\n};\n","/*\n * The KeyStore in Tram-One is a basic key-value object\n * that needs to be persisted in the globalSpace.\n *\n * Currently this is used with useStore and useGlobalStore to keep\n * track of what stores need to be cleaned up when removing elements\n */\n\nimport { buildNamespace } from './namespace';\nimport { KeyObservers } from './types';\n\nconst newDefaultKeyStore = () => {\n\treturn {} as KeyObservers;\n};\n\nexport const { setup: setupKeyStore, get: getKeyStore, set: setKeyStore } = buildNamespace(newDefaultKeyStore);\n\n/**\n * increment (or set initial value) for the keyStore\n */\nexport const incrementKeyStoreValue = (keyStoreName: string, key: string) => {\n\tconst keyStore = getKeyStore(keyStoreName);\n\tkeyStore[key] = keyStore[key] + 1 || 1;\n};\n\n/**\n * decrement a value in the keyStore\n */\nexport const decrementKeyStoreValue = (keyStoreName: string, key: string) => {\n\tconst keyStore = getKeyStore(keyStoreName);\n\tkeyStore[key]--;\n};\n","/*\n * The mutation-observer is a global instance of browsers MutationObserver\n * which tracks when nodes are added or removed.\n *\n * When nodes are added we process their effects. When nodes are removed we process any cleanup,\n * and stop observers that would trigger for that node.\n */\n\nconst { observe, unobserve } = require('@nx-js/observer-util');\n\nimport {\n\tTRAM_TAG,\n\tTRAM_TAG_REACTION,\n\tTRAM_TAG_NEW_EFFECTS,\n\tTRAM_TAG_CLEANUP_EFFECTS,\n\tTRAM_TAG_STORE_KEYS,\n} from './node-names';\nimport { buildNamespace } from './namespace';\nimport { TramOneElement } from './types';\nimport { getObservableStore } from './observable-store';\nimport { TRAM_OBSERVABLE_STORE, TRAM_KEY_STORE } from './engine-names';\nimport { decrementKeyStoreValue, getKeyStore, incrementKeyStoreValue } from './key-store';\n\n/**\n * process side-effects for new tram-one nodes\n * (this includes calling effects, and keeping track of stores)\n */\nconst processTramTags = (node: Node | TramOneElement) => {\n\t// if this element doesn't have a TRAM_TAG, it's not a Tram-One Element\n\tif (!(TRAM_TAG in node)) {\n\t\treturn;\n\t}\n\n\tconst hasStoreKeys = node[TRAM_TAG_STORE_KEYS];\n\n\tif (hasStoreKeys) {\n\t\t// for every store associated with this element, increment the count\n\t\t// - this ensures that it doesn't get blown away when we clean up old stores\n\t\tnode[TRAM_TAG_STORE_KEYS].forEach((key) => {\n\t\t\tincrementKeyStoreValue(TRAM_KEY_STORE, key);\n\t\t});\n\t}\n\n\tconst hasEffects = node[TRAM_TAG_NEW_EFFECTS];\n\n\tif (hasEffects) {\n\t\t// create an array for the cleanup effects\n\t\tnode[TRAM_TAG_CLEANUP_EFFECTS] = [];\n\n\t\t// run all the effects, saving any cleanup functions to the node\n\t\tnode[TRAM_TAG_NEW_EFFECTS].forEach((effect) => {\n\t\t\tlet cleanup: unknown;\n\n\t\t\t// this is called when an effect is re-triggered\n\t\t\tconst effectReaction = observe(() => {\n\t\t\t\t// verify that cleanup is a function before calling it (in case it was a promise)\n\t\t\t\tif (typeof cleanup === 'function') cleanup();\n\t\t\t\tcleanup = effect();\n\t\t\t});\n\n\t\t\t// this is called when a component with an effect is removed\n\t\t\tconst totalCleanup = () => {\n\t\t\t\t// verify that cleanup is a function before calling it (in case it was a promise)\n\t\t\t\tif (typeof cleanup === 'function') cleanup();\n\t\t\t\tunobserve(effectReaction);\n\t\t\t};\n\n\t\t\tnode[TRAM_TAG_CLEANUP_EFFECTS].push(totalCleanup);\n\t\t});\n\n\t\t// set new tag effects to an empty array\n\t\tnode[TRAM_TAG_NEW_EFFECTS] = [];\n\t}\n};\n\n/**\n * call all cleanup effects on the node\n */\nconst cleanupEffects = (cleanupEffects: (() => void)[]) => {\n\tcleanupEffects.forEach((cleanup) => cleanup());\n};\n\n/**\n * remove the association of the store with this specific element\n */\nconst removeStoreKeyAssociation = (storeKeys: string[]) => {\n\tstoreKeys.forEach((storeKey) => {\n\t\tdecrementKeyStoreValue(TRAM_KEY_STORE, storeKey);\n\t});\n};\n\n/**\n * remove any stores that no longer have any elements associated with them\n * see removeStoreKeyAssociation above\n */\nconst cleanUpObservableStores = () => {\n\tconst observableStore = getObservableStore(TRAM_OBSERVABLE_STORE);\n\tconst keyStore = getKeyStore(TRAM_KEY_STORE);\n\tObject.entries(keyStore).forEach(([key, observers]) => {\n\t\tif (observers === 0) {\n\t\t\tdelete observableStore[key];\n\t\t\tdelete keyStore[key];\n\t\t}\n\t});\n};\n\n/**\n * unobserve the reaction tied to the node, and run all cleanup effects for the node\n */\nconst clearNode = (node: Node | TramOneElement) => {\n\t// if this element doesn't have a TRAM_TAG, it's not a Tram-One Element\n\tif (!(TRAM_TAG in node)) {\n\t\treturn;\n\t}\n\n\tunobserve(node[TRAM_TAG_REACTION]);\n\tcleanupEffects(node[TRAM_TAG_CLEANUP_EFFECTS]);\n\tremoveStoreKeyAssociation(node[TRAM_TAG_STORE_KEYS]);\n};\n\nconst isTramOneComponent = (node: Node | TramOneElement) => {\n\t// a node is a component if it has `TRAM_TAG` key on it\n\tconst nodeIsATramOneComponent = TRAM_TAG in node;\n\t// if it is a tram-one component, we want to process it, otherwise skip it\n\treturn nodeIsATramOneComponent ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n};\n\n/**\n * function to get the children (as a list) of the node passed in\n */\nconst childrenComponents = (node: Node | TramOneElement) => {\n\tconst componentWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, isTramOneComponent);\n\tconst children = [];\n\twhile (componentWalker.nextNode()) {\n\t\tchildren.push(componentWalker.currentNode);\n\t}\n\n\treturn children;\n};\n\nconst mutationObserverNamespaceConstructor = () =>\n\tnew MutationObserver((mutationList) => {\n\t\t// cleanup orphaned nodes that are no longer on the DOM\n\t\tconst removedNodesInMutation = (mutation: MutationRecord) => [...mutation.removedNodes];\n\t\tconst removedNodes = mutationList.flatMap(removedNodesInMutation);\n\t\tconst removedChildNodes = removedNodes.flatMap(childrenComponents);\n\n\t\tremovedChildNodes.forEach(clearNode);\n\n\t\t// call new effects on any new nodes\n\t\tconst addedNodesInMutation = (mutation: MutationRecord) => [...mutation.addedNodes];\n\t\tconst newNodes = mutationList.flatMap(addedNodesInMutation);\n\t\tconst newChildNodes = newNodes.flatMap(childrenComponents);\n\n\t\tnewChildNodes.forEach(processTramTags);\n\n\t\t// clean up all local observable stores that have no observers\n\t\tcleanUpObservableStores();\n\t});\n\nexport const { setup: setupMutationObserver, get: getMutationObserver } = buildNamespace(\n\tmutationObserverNamespaceConstructor\n);\n\n// tell the mutation observer to watch the given node for changes\nexport const startWatcher = (observerName: string, node: Element) => {\n\tconst observerStore = getMutationObserver(observerName);\n\n\tobserverStore.observe(node, { childList: true, subtree: true });\n};\n","import mount from './mount';\nimport buildContainer from './build-mounting-container';\nimport {\n\tTRAM_EFFECT_STORE,\n\tTRAM_HOOK_KEY,\n\tTRAM_EFFECT_QUEUE,\n\tTRAM_OBSERVABLE_STORE,\n\tTRAM_MUTATION_OBSERVER,\n\tTRAM_KEY_QUEUE,\n\tTRAM_KEY_STORE,\n} from './engine-names';\nimport { setupTramOneSpace } from './namespace';\nimport { setupEffectStore } from './effect-store';\nimport { setupWorkingKey } from './working-key';\nimport { setupObservableStore } from './observable-store';\nimport { setupMutationObserver, startWatcher } from './mutation-observer';\nimport { ElementOrSelector, TramOneComponent } from './types';\nimport { setupKeyQueue } from './key-queue';\nimport { setupKeyStore } from './key-store';\n\n/**\n * @name start\n * @link https://tram-one.io/#start\n * @description\n * Function to attach a component to an existing element on the page.\n * This function also starts all the listeners and allows the basic hooks to function.\n *\n * This should only be called for the initial render / building of the app.\n *\n * @param component top-level component to attach to the page.\n * @param target either a CSS selector, or Node to attach the component to\n */\nexport default (component: TramOneComponent, target: ElementOrSelector) => {\n\t/* setup all the internal engines required for tram-one to work */\n\n\t// get the container to mount the app on\n\tconst container = buildContainer(target);\n\n\t// setup the window object to hold stores and queues\n\t// in the future, we may allow this to be customized\n\t// for multiple, sandboxed, instances of Tram-One\n\tsetupTramOneSpace();\n\n\t// setup store for effects\n\tsetupEffectStore(TRAM_EFFECT_STORE);\n\n\t// setup queue for new effects when resolving mounts\n\tsetupEffectStore(TRAM_EFFECT_QUEUE);\n\n\t// setup working key for hooks\n\tsetupWorkingKey(TRAM_HOOK_KEY);\n\n\t// setup observable store for the useStore and useGlobalStore hooks\n\tsetupObservableStore(TRAM_OBSERVABLE_STORE);\n\n\t// setup key store for keeping track of stores to clean up\n\tsetupKeyStore(TRAM_KEY_STORE);\n\n\t// setup key queue for new observable stores when resolving mounts\n\tsetupKeyQueue(TRAM_KEY_QUEUE);\n\n\t// setup a mutation observer for cleaning up removed elements and triggering effects\n\tsetupMutationObserver(TRAM_MUTATION_OBSERVER);\n\n\t// watch for changes on the target so that we can process node changes\n\tstartWatcher(TRAM_MUTATION_OBSERVER, container);\n\n\t// trigger an initial mount\n\tmount(component, container);\n};\n"],"names":["observe"],"mappings":"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"}