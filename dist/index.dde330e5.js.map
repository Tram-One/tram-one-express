{"mappings":"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","sources":["node_modules/tram-one/src/engine-names.ts","node_modules/tram-one/src/namespace.ts","node_modules/tram-one/src/working-key.ts","node_modules/@nx-js/observer-util/dist/es.es5.js","node_modules/tram-one/src/observe-tag.ts","node_modules/tram-one/src/node-names.ts","node_modules/tram-one/src/effect-store.ts","node_modules/tram-one/src/key-queue.ts","node_modules/tram-one/src/process-hooks.ts","node_modules/@tram-one/nanohtml/appendChild.js","node_modules/@tram-one/nanohtml/index.js","node_modules/@tram-one/rbel/index.js","node_modules/hyperscript-attribute-to-property/index.js","node_modules/@tram-one/hyperx/index.js","node_modules/tram-one/src/dom.ts","node_modules/tram-one/src/dom-wrappers.ts","node_modules/tram-one/src/use-effect.ts","node_modules/tram-one/src/observable-store.ts","node_modules/rlite-router/rlite.js","node_modules/use-url-params/urlParamHook.js","node_modules/use-url-params/setupUrlParams.js","node_modules/use-url-params/useUrlParams.js","node_modules/use-url-params/index.js","node_modules/tram-one/src/build-mounting-container.ts","node_modules/tram-one/src/key-store.ts","node_modules/tram-one/src/mutation-observer.ts","node_modules/@tram-one/tram-logo/dist/src/element.js","node_modules/@tram-one/tram-logo/dist/node_modules/@parcel/runtime-js/lib/bundles/runtime-3bd850773567280e.js","src/app.ts","node_modules/tram-one/src/start.ts","node_modules/tram-one/src/mount.ts","src/index.ts"],"sourcesContent":["/*\n * This file is a collection of strings used to store values\n * in the tram-one global space. If you ever need to debug Tram-One's\n * internal state, you can inspect these on the window.\n *\n * e.g. `window['tram-space']['tram-hook-key']`\n */\n\nexport const TRAM_HOOK_KEY = 'tram-hook-key';\nexport const TRAM_EFFECT_STORE = 'tram-effect-store';\nexport const TRAM_EFFECT_QUEUE = 'tram-effect-queue';\nexport const TRAM_KEY_STORE = 'tram-key-store';\nexport const TRAM_KEY_QUEUE = 'tram-key-queue';\nexport const TRAM_OBSERVABLE_STORE = 'tram-observable-store';\nexport const TRAM_MUTATION_OBSERVER = 'tram-mutation-observer';\n","/*\n * namespace is a generic interface for global tram-one state that needs\n * to be persisted in the app container. It exposes a setup and get function.\n */\n\nimport { TramWindow } from './types';\n\nconst getTramWindow = (): TramWindow => {\n\t// if tram-one is setup it will have a defined value in the 'tram-space'\n\tconst tramOneIsSetup = (window as unknown as TramWindow)['tram-space'];\n\n\t// otherwise, we should warn\n\t// this usually happens when calling a hook outside of a component function\n\t// but this could be potentially triggered other ways - if we find those, we should broaden the message then\n\tif (!tramOneIsSetup) {\n\t\tthrow new Error(`\n\t\t\tTram-One: app has not started yet, but hook was called. Is it being invoked outside a component function?\n\t\t\thttps://github.com/Tram-One/tram-one/issues/178\n\t\t`);\n\t}\n\n\treturn window as unknown as TramWindow;\n};\n\nexport const setupTramOneSpace = () => {\n\t(window as unknown as TramWindow)['tram-space'] = {};\n};\n\nexport const buildNamespace = <NamespaceStore>(constructor: () => NamespaceStore) => {\n\tconst setup = (namespace: string): NamespaceStore => {\n\t\tconst tramWindow = getTramWindow();\n\t\ttramWindow['tram-space'][namespace] = constructor();\n\t\treturn tramWindow['tram-space'][namespace];\n\t};\n\n\tconst get = (namespace: string): NamespaceStore => {\n\t\tconst tramWindow = getTramWindow();\n\t\treturn tramWindow['tram-space'][namespace];\n\t};\n\n\tconst set = (namespace: string, value: NamespaceStore) => {\n\t\tconst tramWindow = getTramWindow();\n\t\ttramWindow['tram-space'][namespace] = value;\n\t};\n\n\treturn { setup, get, set };\n};\n","import { buildNamespace } from './namespace';\nimport { WorkingkeyObject } from './types';\n\n/*\n * This file defines all the functions required to interact with\n * a working-key object. This working-key object is used to help\n * hooks understand where in the mounting process we are, and what\n * values or effects to pull / trigger.\n */\n\nconst defaultWorkingKey = () =>\n\t({\n\t\t// list of custom tags that we've stepped into\n\t\tbranch: [],\n\t\t// map of branches to index value (used as a cursor for hooks)\n\t\tbranchIndices: {\n\t\t\t'': 0,\n\t\t},\n\t} as WorkingkeyObject);\n\nexport const { setup: setupWorkingKey, get: getWorkingKey } = buildNamespace(defaultWorkingKey);\n\nconst getWorkingBranch = (keyName: string) => {\n\tconst workingkeyObject = getWorkingKey(keyName);\n\treturn workingkeyObject.branch.join('/');\n};\n\n/**\n * push a new branch value, usually when we step into a new\n * custom component when mounting.\n */\nexport const pushWorkingKeyBranch = (keyName: string, branch: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\tworkingKey.branch.push(branch);\n\tif (!workingKey.branchIndices[getWorkingBranch(keyName)]) {\n\t\tworkingKey.branchIndices[getWorkingBranch(keyName)] = 0;\n\t}\n};\n\n/**\n * pops the current branch value, usually when we are done mounting\n * a single child component.\n */\nexport const popWorkingKeyBranch = (keyName: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\tworkingKey.branch.pop();\n};\n\n/**\n * increments the value for the current branch.\n * These values are used to pull the correct hook value on re-renders.\n */\nexport const incrementWorkingKeyBranch = (keyName: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\tworkingKey.branchIndices[getWorkingBranch(keyName)] += 1;\n};\n\n/**\n * used to get a unique string that will be used as a key for observables and effects.\n * This unique string _should_ be consistent over many re-renders.\n */\nexport const getWorkingKeyValue = (keyName: string) => {\n\tconst workingKey = getWorkingKey(keyName);\n\n\tconst index = workingKey.branchIndices[getWorkingBranch(keyName)];\n\treturn `${getWorkingBranch(keyName)}[${index}]`;\n};\n\n/**\n * returns a deep copy of the existing key, usually used as a restore point later\n */\nexport const copyWorkingKey = (keyName: string) => {\n\tconst key = getWorkingKey(keyName);\n\treturn {\n\t\tbranch: [...key.branch],\n\t\tbranchIndices: { ...key.branchIndices },\n\t};\n};\n\n/**\n * if we needed to reset pre-emptively, use this to get back\n * to where the branches were before\n */\nexport const restoreWorkingKey = (keyName: string, restoreKey: WorkingkeyObject) => {\n\tconst key = getWorkingKey(keyName);\n\tconst branches = key.branchIndices;\n\n\tkey.branch = [...restoreKey.branch];\n\n\tconst resetBranchValue = (branch: string) => {\n\t\tbranches[branch] = restoreKey.branchIndices[branch] || 0;\n\t};\n\tObject.keys(key.branchIndices).forEach(resetBranchValue);\n};\n","var connectionStore = new WeakMap();\nvar ITERATION_KEY = Symbol('iteration key');\n\nfunction storeObservable(obj) {\n  // this will be used to save (obj.key -> reaction) connections later\n  connectionStore.set(obj, new Map());\n}\n\nfunction registerReactionForOperation(reaction, ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  if (type === 'iterate') {\n    key = ITERATION_KEY;\n  }\n\n  var reactionsForObj = connectionStore.get(target);\n  var reactionsForKey = reactionsForObj.get(key);\n  if (!reactionsForKey) {\n    reactionsForKey = new Set();\n    reactionsForObj.set(key, reactionsForKey);\n  }\n  // save the fact that the key is used by the reaction during its current run\n  if (!reactionsForKey.has(reaction)) {\n    reactionsForKey.add(reaction);\n    reaction.cleaners.push(reactionsForKey);\n  }\n}\n\nfunction getReactionsForOperation(ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  var reactionsForTarget = connectionStore.get(target);\n  var reactionsForKey = new Set();\n\n  if (type === 'clear') {\n    reactionsForTarget.forEach(function (_, key) {\n      addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n    });\n  } else {\n    addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n  }\n\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;\n    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);\n  }\n\n  return reactionsForKey;\n}\n\nfunction addReactionsForKey(reactionsForKey, reactionsForTarget, key) {\n  var reactions = reactionsForTarget.get(key);\n  reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);\n}\n\nfunction releaseReaction(reaction) {\n  if (reaction.cleaners) {\n    reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);\n  }\n  reaction.cleaners = [];\n}\n\nfunction releaseReactionKeyConnection(reactionsForKey) {\n  reactionsForKey.delete(this);\n}\n\n// reactions can call each other and form a call stack\nvar reactionStack = [];\nvar isDebugging = false;\n\nfunction runAsReaction(reaction, fn, context, args) {\n  // do not build reactive relations, if the reaction is unobserved\n  if (reaction.unobserved) {\n    return Reflect.apply(fn, context, args);\n  }\n\n  // only run the reaction if it is not already in the reaction stack\n  // TODO: improve this to allow explicitly recursive reactions\n  if (reactionStack.indexOf(reaction) === -1) {\n    // release the (obj -> key -> reactions) connections\n    // and reset the cleaner connections\n    releaseReaction(reaction);\n\n    try {\n      // set the reaction as the currently running one\n      // this is required so that we can create (observable.prop -> reaction) pairs in the get trap\n      reactionStack.push(reaction);\n      return Reflect.apply(fn, context, args);\n    } finally {\n      // always remove the currently running flag from the reaction when it stops execution\n      reactionStack.pop();\n    }\n  }\n}\n\n// register the currently running reaction to be queued again on obj.key mutations\nfunction registerRunningReactionForOperation(operation) {\n  // get the current reaction from the top of the stack\n  var runningReaction = reactionStack[reactionStack.length - 1];\n  if (runningReaction) {\n    debugOperation(runningReaction, operation);\n    registerReactionForOperation(runningReaction, operation);\n  }\n}\n\nfunction queueReactionsForOperation(operation) {\n  // iterate and queue every reaction, which is triggered by obj.key mutation\n  getReactionsForOperation(operation).forEach(queueReaction, operation);\n}\n\nfunction queueReaction(reaction) {\n  debugOperation(reaction, this);\n  // queue the reaction for later execution or run it immediately\n  if (typeof reaction.scheduler === 'function') {\n    reaction.scheduler(reaction);\n  } else if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.add(reaction);\n  } else {\n    reaction();\n  }\n}\n\nfunction debugOperation(reaction, operation) {\n  if (reaction.debugger && !isDebugging) {\n    try {\n      isDebugging = true;\n      reaction.debugger(operation);\n    } finally {\n      isDebugging = false;\n    }\n  }\n}\n\nfunction hasRunningReaction() {\n  return reactionStack.length > 0;\n}\n\nvar IS_REACTION = Symbol('is reaction');\n\nfunction observe(fn, options) {\n  if ( options === void 0 ) options = {};\n\n  // wrap the passed function in a reaction, if it is not already one\n  var reaction = fn[IS_REACTION] ? fn : function reaction() {\n    return runAsReaction(reaction, fn, this, arguments);\n  };\n  // save the scheduler and debugger on the reaction\n  reaction.scheduler = options.scheduler;\n  reaction.debugger = options.debugger;\n  // save the fact that this is a reaction\n  reaction[IS_REACTION] = true;\n  // run the reaction once if it is not a lazy one\n  if (!options.lazy) {\n    reaction();\n  }\n  return reaction;\n}\n\nfunction unobserve(reaction) {\n  // do nothing, if the reaction is already unobserved\n  if (!reaction.unobserved) {\n    // indicate that the reaction should not be triggered any more\n    reaction.unobserved = true;\n    // release (obj -> key -> reaction) connections\n    releaseReaction(reaction);\n  }\n  // unschedule the reaction, if it is scheduled\n  if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.delete(reaction);\n  }\n}\n\nvar proxyToRaw = new WeakMap();\nvar rawToProxy = new WeakMap();\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction findObservable(obj) {\n  var observableObj = rawToProxy.get(obj);\n  if (hasRunningReaction() && typeof obj === 'object' && obj !== null) {\n    if (observableObj) {\n      return observableObj;\n    }\n    return observable(obj);\n  }\n  return observableObj || obj;\n}\n\nfunction patchIterator(iterator, isEntries) {\n  var originalNext = iterator.next;\n  iterator.next = function () {\n    var ref = originalNext.call(iterator);\n    var done = ref.done;\n    var value = ref.value;\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(value[1]);\n      } else {\n        value = findObservable(value);\n      }\n    }\n    return { done: done, value: value };\n  };\n  return iterator;\n}\n\nvar instrumentations = {\n  has: function has(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n    return proto.has.apply(target, arguments);\n  },\n  get: function get(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, key: key, type: 'get' });\n    return findObservable(proto.get.apply(target, arguments));\n  },\n  add: function add(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    // forward the operation before queueing reactions\n    var result = proto.add.apply(target, arguments);\n    if (!hadKey) {\n      queueReactionsForOperation({ target: target, key: key, value: key, type: 'add' });\n    }\n    return result;\n  },\n  set: function set(key, value) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get.call(target, key);\n    // forward the operation before queueing reactions\n    var result = proto.set.apply(target, arguments);\n    if (!hadKey) {\n      queueReactionsForOperation({ target: target, key: key, value: value, type: 'add' });\n    } else if (value !== oldValue) {\n      queueReactionsForOperation({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });\n    }\n    return result;\n  },\n  delete: function delete$1(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get ? proto.get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    var result = proto.delete.apply(target, arguments);\n    if (hadKey) {\n      queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n    }\n    return result;\n  },\n  clear: function clear() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadItems = target.size !== 0;\n    var oldTarget = target instanceof Map ? new Map(target) : new Set(target);\n    // forward the operation before queueing reactions\n    var result = proto.clear.apply(target, arguments);\n    if (hadItems) {\n      queueReactionsForOperation({ target: target, oldTarget: oldTarget, type: 'clear' });\n    }\n    return result;\n  },\n  forEach: function forEach(cb) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    // swap out the raw values with their observable pairs\n    // before passing them to the callback\n    var wrappedCb = function (value) {\n      var rest = [], len = arguments.length - 1;\n      while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n      return cb.apply(void 0, [ findObservable(value) ].concat( rest ));\n    };\n    return (ref = proto.forEach).call.apply(ref, [ target, wrappedCb ].concat( args ));\n    var ref;\n  },\n  keys: function keys() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto.keys.apply(target, arguments);\n  },\n  values: function values() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    var iterator = proto.values.apply(target, arguments);\n    return patchIterator(iterator, false);\n  },\n  entries: function entries() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    var iterator = proto.entries.apply(target, arguments);\n    return patchIterator(iterator, true);\n  },\n  get size() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return Reflect.get(proto, 'size', target);\n  }\n};\ninstrumentations[Symbol.iterator] = function () {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    var iterator = proto[Symbol.iterator].apply(target, arguments);\n    return patchIterator(iterator, target instanceof Map);\n  };\n\nvar collectionHandlers = {\n  get: function get(target, key, receiver) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key) ? instrumentations : target;\n    return Reflect.get(target, key, receiver);\n  }\n};\n\n// eslint-disable-next-line\nvar globalObj = typeof window === 'object' ? window : Function('return this')();\n\n// built-in object can not be wrapped by Proxies\n// their methods expect the object instance as the 'this' instead of the Proxy wrapper\n// complex objects are wrapped with a Proxy of instrumented methods\n// which switch the proxy to the raw object and to add reactive wiring\nvar handlers = new Map([[Map, collectionHandlers], [Set, collectionHandlers], [WeakMap, collectionHandlers], [WeakSet, collectionHandlers], [Object, false], [Array, false], [Int8Array, false], [Uint8Array, false], [Uint8ClampedArray, false], [Int16Array, false], [Uint16Array, false], [Int32Array, false], [Uint32Array, false], [Float32Array, false], [Float64Array, false]]);\n\nfunction shouldInstrument(ref) {\n  var constructor = ref.constructor;\n\n  var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;\n  return !isBuiltIn || handlers.has(constructor);\n}\n\nfunction getHandlers(obj) {\n  return handlers.get(obj.constructor);\n}\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) { return Symbol[key]; }).filter(function (value) { return typeof value === 'symbol'; }));\n\n// intercept get operations on observables to know which reaction uses their properties\nfunction get(target, key, receiver) {\n  var result = Reflect.get(target, key, receiver);\n  // do not register (observable.prop -> reaction) pairs for well known symbols\n  // these symbols are frequently retrieved in low level JavaScript under the hood\n  if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n    return result;\n  }\n  // register and save (observable.prop -> runningReaction)\n  registerRunningReactionForOperation({ target: target, key: key, receiver: receiver, type: 'get' });\n  // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n  // this is needed to intercept property access on that object too (dynamic observable tree)\n  var observableResult = rawToProxy.get(result);\n  if (hasRunningReaction() && typeof result === 'object' && result !== null) {\n    if (observableResult) {\n      return observableResult;\n    }\n    // do not violate the none-configurable none-writable prop get handler invariant\n    // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n    var descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n    if (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) {\n      return observable(result);\n    }\n  }\n  // otherwise return the observable wrapper if it is already created and cached or the raw object\n  return observableResult || result;\n}\n\nfunction has(target, key) {\n  var result = Reflect.has(target, key);\n  // register and save (observable.prop -> runningReaction)\n  registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n  return result;\n}\n\nfunction ownKeys(target) {\n  registerRunningReactionForOperation({ target: target, type: 'iterate' });\n  return Reflect.ownKeys(target);\n}\n\n// intercept set operations on observables to know when to trigger reactions\nfunction set(target, key, value, receiver) {\n  // make sure to do not pollute the raw object with observables\n  if (typeof value === 'object' && value !== null) {\n    value = proxyToRaw.get(value) || value;\n  }\n  // save if the object had a descriptor for this key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  // save if the value changed because of this set operation\n  var oldValue = target[key];\n  // execute the set operation before running any reaction\n  var result = Reflect.set(target, key, value, receiver);\n  // do not queue reactions if the target of the operation is not the raw receiver\n  // (possible because of prototypal inheritance)\n  if (target !== proxyToRaw.get(receiver)) {\n    return result;\n  }\n  // queue a reaction if it's a new property or its value changed\n  if (!hadKey) {\n    queueReactionsForOperation({ target: target, key: key, value: value, receiver: receiver, type: 'add' });\n  } else if (value !== oldValue) {\n    queueReactionsForOperation({\n      target: target,\n      key: key,\n      value: value,\n      oldValue: oldValue,\n      receiver: receiver,\n      type: 'set'\n    });\n  }\n  return result;\n}\n\nfunction deleteProperty(target, key) {\n  // save if the object had the key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  var oldValue = target[key];\n  // execute the delete operation before running any reaction\n  var result = Reflect.deleteProperty(target, key);\n  // only queue reactions for delete operations which resulted in an actual change\n  if (hadKey) {\n    queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n  }\n  return result;\n}\n\nvar baseHandlers = { get: get, has: has, ownKeys: ownKeys, set: set, deleteProperty: deleteProperty };\n\nfunction observable(obj) {\n  if ( obj === void 0 ) obj = {};\n\n  // if it is already an observable or it should not be wrapped, return it\n  if (proxyToRaw.has(obj) || !shouldInstrument(obj)) {\n    return obj;\n  }\n  // if it already has a cached observable wrapper, return it\n  // otherwise create a new observable\n  return rawToProxy.get(obj) || createObservable(obj);\n}\n\nfunction createObservable(obj) {\n  // if it is a complex built-in object or a normal object, wrap it\n  var handlers = getHandlers(obj) || baseHandlers;\n  var observable = new Proxy(obj, handlers);\n  // save these to switch between the raw object and the wrapped object with ease later\n  rawToProxy.set(obj, observable);\n  proxyToRaw.set(observable, obj);\n  // init basic data structures to save and cleanup later (observable.prop -> reaction) connections\n  storeObservable(obj);\n  return observable;\n}\n\nfunction isObservable(obj) {\n  return proxyToRaw.has(obj);\n}\n\nfunction raw(obj) {\n  return proxyToRaw.get(obj) || obj;\n}\n\nexport { observe, unobserve, observable, isObservable, raw };\n","const { observe } = require('@nx-js/observer-util');\n\nimport { TRAM_TAG_REACTION, TRAM_TAG_NEW_EFFECTS, TRAM_TAG_CLEANUP_EFFECTS, TRAM_TAG } from './node-names';\nimport { TramOneElement, RemovedElementDataStore, Reaction, ElementPotentiallyWithSelectionAndFocus } from './types';\n\n// functions to go to nodes or indices (made for .map)\nconst toIndices = (node: Node, index: number) => index;\n\n// sorting function that prioritizes indices that are closest to a target\n// e.g. target = 3, [1, 2, 3, 4, 5] => [3, 2, 4, 1, 5]\nconst byDistanceFromIndex = (targetIndex: number) => (indexA: number, indexB: number) => {\n\tconst diffFromTargetA = Math.abs(indexA - targetIndex);\n\tconst diffFromTargetB = Math.abs(indexB - targetIndex);\n\treturn diffFromTargetA - diffFromTargetB;\n};\n\nconst hasMatchingTagName = (tagName: string) => (node: Node | Element) => {\n\tconst nodeHasMatchingTagName = 'tagName' in node && node.tagName === tagName;\n\t// if the tagName matches, we want to process the node, otherwise skip it\n\treturn nodeHasMatchingTagName ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n};\n\n// get an array including the element and all it's children\nconst parentAndChildrenElements = (node: Element, tagName: string) => {\n\tconst matchesTagName = hasMatchingTagName(tagName);\n\tconst componentWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, matchesTagName);\n\tconst parentAndChildren = [componentWalker.currentNode];\n\twhile (componentWalker.nextNode()) {\n\t\tparentAndChildren.push(componentWalker.currentNode);\n\t}\n\n\t// since we are looking for elements (things with tagNames)\n\t// we can safely declare this as an array of Elements\n\treturn parentAndChildren as Element[];\n};\n\nconst defaultRemovedElementWithFocusData: RemovedElementDataStore = {\n\tindex: -1,\n\ttagName: '',\n\tscrollLeft: 0,\n\tscrollTop: 0,\n\tselectionStart: null,\n\tselectionEnd: null,\n\tselectionDirection: undefined,\n};\n\n/**\n * This is a helper function for the dom creation.\n * This function observes any state values used when making the tag, and allow it to update\n * independently when one of those state values updates.\n *\n * The mutation-observer will unobserve any reactions here when the node is removed.\n *\n * The parameter tagFunction is almost a TramOneComponent, but it already has the props and children prepopulated,\n * and so has no parameters, but returns a TramOneElement\n */\nexport default (tagFunction: () => TramOneElement): TramOneElement => {\n\tlet tagResult: TramOneElement | undefined;\n\tconst buildAndReplaceTag = () => {\n\t\t// if there is an existing tagResult, it is the last rendering, and so we want to re-render over it\n\t\tlet oldTag = tagResult;\n\t\tlet removedElementWithFocusData = defaultRemovedElementWithFocusData;\n\n\t\t// remove oldTag first so that we unobserve before we re-observe\n\t\tif (oldTag) {\n\t\t\t// we need to blow away any old focus data we had\n\t\t\tremovedElementWithFocusData = defaultRemovedElementWithFocusData;\n\n\t\t\t// determine if this element (or any element under it) had focus\n\t\t\tconst oldTagHasFocusedElement = oldTag.contains(document.activeElement);\n\n\t\t\t// if an element had focus, copy over all the selection data (so we can copy it back later)\n\t\t\tif (oldTagHasFocusedElement) {\n\t\t\t\t// we'll assume that the element is an HTMLInputElement, in reality other kinds of elements will be caught here,\n\t\t\t\t// but that's fine, since they have null as selection attributes, and setting them to null is fine\n\t\t\t\tconst activeElement = document.activeElement as HTMLInputElement;\n\n\t\t\t\t// first, we need to get all the elements that are similar (we'll use tagName)\n\t\t\t\t// this way, when we rerender, we can search for those tagNames, and just use the index we got here\n\t\t\t\tconst allActiveLikeElements = parentAndChildrenElements(oldTag, activeElement.tagName);\n\t\t\t\tremovedElementWithFocusData.index = allActiveLikeElements.findIndex((element) => element === activeElement);\n\n\t\t\t\t// copy over the data\n\t\t\t\tremovedElementWithFocusData.tagName = activeElement.tagName;\n\t\t\t\tremovedElementWithFocusData.scrollLeft = activeElement.scrollLeft;\n\t\t\t\tremovedElementWithFocusData.scrollTop = activeElement.scrollTop;\n\t\t\t\tremovedElementWithFocusData.selectionStart = activeElement.selectionStart;\n\t\t\t\tremovedElementWithFocusData.selectionEnd = activeElement.selectionEnd;\n\t\t\t\tremovedElementWithFocusData.selectionDirection = activeElement.selectionDirection || undefined;\n\t\t\t}\n\n\t\t\tconst emptyDiv = document.createElement('div') as unknown as TramOneElement;\n\t\t\toldTag.replaceWith(emptyDiv);\n\n\t\t\t// copy the reaction and effects from the old tag to the empty div so we don't lose them\n\t\t\temptyDiv[TRAM_TAG_REACTION] = oldTag[TRAM_TAG_REACTION];\n\t\t\temptyDiv[TRAM_TAG_NEW_EFFECTS] = oldTag[TRAM_TAG_NEW_EFFECTS];\n\t\t\temptyDiv[TRAM_TAG_CLEANUP_EFFECTS] = oldTag[TRAM_TAG_CLEANUP_EFFECTS];\n\n\t\t\t// set oldTag to emptyDiv, so we can replace it later\n\t\t\toldTag = emptyDiv;\n\t\t}\n\n\t\t// build the component\n\t\ttagResult = tagFunction();\n\n\t\t// if oldTag was defined, then we need to replace it with the new result\n\t\tif (oldTag) {\n\t\t\t// if an element had focus, reapply it\n\t\t\tlet elementToGiveFocus;\n\t\t\tif (removedElementWithFocusData.index >= 0) {\n\t\t\t\tconst allActiveLikeElements = parentAndChildrenElements(tagResult, removedElementWithFocusData.tagName);\n\n\t\t\t\t// we'll look through the elements (in order of nodes closest to original index) and find a tag that matches.\n\t\t\t\t// this means if it didn't move, we'll get it right away,\n\t\t\t\t// if it did, we'll look at the elements closest to the original position\n\t\t\t\tconst elementIndexToGiveFocus = allActiveLikeElements\n\t\t\t\t\t.map(toIndices)\n\t\t\t\t\t.sort(byDistanceFromIndex(removedElementWithFocusData.index))[0];\n\n\t\t\t\telementToGiveFocus = allActiveLikeElements[elementIndexToGiveFocus] as ElementPotentiallyWithSelectionAndFocus;\n\t\t\t\t// also try to set the selection, if there is a selection for this element\n\t\t\t\ttry {\n\t\t\t\t\tif (elementToGiveFocus.setSelectionRange !== undefined) {\n\t\t\t\t\t\telementToGiveFocus.setSelectionRange(\n\t\t\t\t\t\t\tremovedElementWithFocusData.selectionStart,\n\t\t\t\t\t\t\tremovedElementWithFocusData.selectionEnd,\n\t\t\t\t\t\t\tremovedElementWithFocusData.selectionDirection\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (exception) {\n\t\t\t\t\t// don't worry if we fail\n\t\t\t\t\t// this can happen if the element has a `setSelectionRange` but it isn't supported\n\t\t\t\t\t// e.g. input with type=\"range\"\n\t\t\t\t}\n\n\t\t\t\telementToGiveFocus.scrollLeft = removedElementWithFocusData.scrollLeft;\n\t\t\t\telementToGiveFocus.scrollTop = removedElementWithFocusData.scrollTop;\n\t\t\t}\n\n\t\t\t// don't lose track that this is still a tram-one element\n\t\t\ttagResult[TRAM_TAG] = true;\n\n\t\t\t// copy the reaction and effects from the old tag to the new one\n\t\t\ttagResult[TRAM_TAG_REACTION] = oldTag[TRAM_TAG_REACTION];\n\t\t\ttagResult[TRAM_TAG_NEW_EFFECTS] = oldTag[TRAM_TAG_NEW_EFFECTS];\n\t\t\ttagResult[TRAM_TAG_CLEANUP_EFFECTS] = oldTag[TRAM_TAG_CLEANUP_EFFECTS];\n\n\t\t\t// both these actions cause forced reflow, and can be performance issues\n\t\t\toldTag.replaceWith(tagResult);\n\t\t\tif (elementToGiveFocus && elementToGiveFocus.focus) elementToGiveFocus.focus();\n\t\t}\n\t};\n\n\tconst tagReaction = observe(buildAndReplaceTag) as Reaction;\n\n\t// tagResult is always assigned as an artifact of the observe() call above\n\t// if it isn't, we want to know about it\n\tif (tagResult === undefined) {\n\t\tthrow new Error(`\n\t\t\tTram-One: tagResult was not defined after building the tag.\n\t\t\thttps://github.com/Tram-One/tram-one/issues/177\n\t\t`);\n\t}\n\n\t// save the reaction to the node, so that the mutation-observer can unobserve it later\n\ttagResult[TRAM_TAG_REACTION] = tagReaction;\n\n\treturn tagResult;\n};\n","/*\n * This file is a collection of strings used to store values\n * in custom elements. If you ever need to debug Tram-One's\n * internal state, you can inspect these on individual elements.\n *\n * e.g. `$0['tram-hook-key']`\n */\n\nexport const TRAM_TAG = 'tram-tag';\nexport const TRAM_TAG_REACTION = 'tram-tag-reaction';\nexport const TRAM_TAG_STORE_KEYS = 'tram-tag-store-keys';\nexport const TRAM_TAG_NEW_EFFECTS = 'tram-tag-new-effects';\nexport const TRAM_TAG_CLEANUP_EFFECTS = 'tram-tag-cleanup-effects';\n","/*\n * EffectStores in Tram-One are used for basic key-value object mappings that need\n * to be persisted in the globalSpace.\n *\n * Currently this is used with useEffect to keep track of what\n * new effects should be triggered or cleaned up\n */\n\nimport { buildNamespace } from './namespace';\nimport { EffectStore } from './types';\n\nconst newDefaultEffectStore = () => {\n\treturn {} as EffectStore;\n};\n\nexport const {\n\tsetup: setupEffectStore,\n\tget: getEffectStore,\n\tset: setEffectStore,\n} = buildNamespace(newDefaultEffectStore);\n\n/**\n * clear the effect store\n * usually called when we want to empty the effect store\n */\nexport const clearEffectStore = (effectStoreName: string) => {\n\tconst effectStore = getEffectStore(effectStoreName);\n\n\tObject.keys(effectStore).forEach((key) => delete effectStore[key]);\n};\n\n/**\n * restore the effect store to a previous value\n * usually used when we had to interrupt the processing of effects\n */\nexport const restoreEffectStore = setEffectStore;\n","/*\n * The KeyQueue in Tram-One is a basic list of keys\n * that needs to be persisted in the globalSpace.\n *\n * Currently this is used with useStore to keep track of what\n * stores need to be associated with generated elements\n */\n\nimport { buildNamespace } from './namespace';\n\nconst newDefaultKeyQueue = () => {\n\treturn [] as string[];\n};\n\nexport const { setup: setupKeyQueue, get: getKeyQueue, set: setKeyQueue } = buildNamespace(newDefaultKeyQueue);\n\n/**\n * clear the key queue\n * usually called when we want to empty the key queue\n */\nexport const clearKeyQueue = (keyQueueName: string) => {\n\tconst keyQueue = getKeyQueue(keyQueueName);\n\n\tkeyQueue.splice(0, keyQueue.length);\n};\n\n/**\n * restore the key queue to a previous value\n * usually used when we had to interrupt the processing of keys\n */\nexport const restoreKeyQueue = setKeyQueue;\n","import { TRAM_EFFECT_STORE, TRAM_EFFECT_QUEUE, TRAM_KEY_QUEUE } from './engine-names';\nimport { TRAM_TAG_NEW_EFFECTS, TRAM_TAG_STORE_KEYS } from './node-names';\nimport { getEffectStore, clearEffectStore, restoreEffectStore } from './effect-store';\nimport { TramOneElement } from './types';\nimport { clearKeyQueue, getKeyQueue, restoreKeyQueue } from './key-queue';\n\n/**\n * This is a helper function for the dom creation.\n * This function stores any keys generated when building a tag in the resulting node that is generated.\n *\n * These are later processed by the mutation-observer, and cleaned up when the node is removed by the mutation-observer.\n *\n * This function is called every time state changes in an observable store\n */\nexport default (tagFunction: () => TramOneElement) => {\n\t// save the existing effect queue and key queue for any components we are in the middle of building\n\tconst existingQueuedEffects = { ...getEffectStore(TRAM_EFFECT_QUEUE) };\n\tconst existingQueuedKeys = [...getKeyQueue(TRAM_KEY_QUEUE)];\n\n\t// clear the queues (so we can get just new effects and keys)\n\tclearEffectStore(TRAM_EFFECT_QUEUE);\n\tclearKeyQueue(TRAM_KEY_QUEUE);\n\n\t// create the component, which will save new effects to the effect queue\n\tconst tagResult = tagFunction();\n\n\t// see if there are any brand new effects\n\tconst existingEffects = getEffectStore(TRAM_EFFECT_STORE);\n\tconst queuedEffects = getEffectStore(TRAM_EFFECT_QUEUE);\n\n\t// get all new keys\n\tconst newKeys = getKeyQueue(TRAM_KEY_QUEUE);\n\n\t// store new effects in the node we just built\n\tconst newEffects = Object.keys(queuedEffects).filter((effect) => !(effect in existingEffects));\n\ttagResult[TRAM_TAG_NEW_EFFECTS] = newEffects.map((newEffectKey) => queuedEffects[newEffectKey]);\n\n\t// store keys in the node we just built\n\ttagResult[TRAM_TAG_STORE_KEYS] = newKeys;\n\n\t// restore the effect and key queues to what they were before we started\n\trestoreEffectStore(TRAM_EFFECT_QUEUE, existingQueuedEffects);\n\trestoreKeyQueue(TRAM_KEY_QUEUE, existingQueuedKeys);\n\n\treturn tagResult;\n};\n","const parseNodeAsString = node => (typeof node === 'number' ||\n                                   typeof node === 'boolean' ||\n                                   typeof node === 'function' ||\n                                   node instanceof Date ||\n                                   node instanceof RegExp) ? node.toString() : node\n\nconst isNotWhitespace = node => !(typeof node === 'string' && /^[\\n\\r\\s]+$/.test(node))\n\nconst appendChild = (element, childs) => {\n  if (!Array.isArray(childs)) return\n  childs\n    .map(parseNodeAsString)\n    .filter(isNotWhitespace)\n    .forEach((node) => {\n      if (Array.isArray(node)) {\n        appendChild(element, node)\n        return\n      }\n\n      if (typeof node === 'string') {\n        if (element.lastChild && element.lastChild.nodeName === '#text') {\n          element.lastChild.nodeValue += node\n          return\n        }\n        node = document.createTextNode(node)\n      }\n\n      if (node && node.nodeType) {\n        element.appendChild(node)\n      }\n    })\n}\n\nmodule.exports = appendChild\n","const appendChild = require('./appendChild')\n\nconst COMMENT_TAG = '!--'\n\n// filters for attributes\nconst isNotXMLNSprop = prop => !/^xmlns($|:)/i.test(prop)\nconst containsOwnProp = props => prop => Object.prototype.hasOwnProperty.call(props, prop)\n\n// map to objects so we know their value\nconst toObjectList = props => prop => ({key: prop, value: props[prop]})\n\n// transformations for attributes\nconst normalizeClassName = prop => prop.key.toLowerCase() === 'classname' ? ({key: 'class', value: prop.value}) : prop\nconst htmlForToFor = prop => prop.key === 'htmlFor' ? ({key: 'for', value: prop.value}) : prop\n\nconst addEventToElement = (element, eventKey, eventValue) => {\n  element[eventKey] = eventValue\n  // add event to element list of events\n  element.events = element.events ? element.events.concat(eventKey) : [eventKey]\n}\n\n// handlers that can be filtered on\n// if something gets processed, we return false\n// otherwise, it returns true, indicating that this thing needs to be processed\nconst handleEventSetter = element => prop => prop.key.slice(0, 2) === 'on' ? addEventToElement(element, prop.key, prop.value) : true\nconst handleAttrSetter = element => prop => element.setAttributeNS(null, prop.key, prop.value)\n\nconst nanoCreateElement = (namespace) => (tag, props, children) => {\n  // if the tag is a comment\n  if (tag === COMMENT_TAG) {\n    return document.createComment(props.comment)\n  }\n\n  // create the element\n  const element = namespace ? document.createElementNS(namespace, tag) : document.createElement(tag)\n\n  // attach the properties\n  Object.keys(props)\n    .filter(isNotXMLNSprop)\n    .filter(containsOwnProp(props))\n    .map(toObjectList(props))\n    .map(normalizeClassName)\n    .map(htmlForToFor)\n    .filter(handleEventSetter(element))\n    .filter(handleAttrSetter(element))\n\n  appendChild(element, children)\n  return element\n}\n\nmodule.exports = nanoCreateElement\nmodule.exports.html = nanoCreateElement()\nmodule.exports.svg = nanoCreateElement('http://www.w3.org/2000/svg')\n","module.exports = function (domBuilder, h, components) {\n    const eh = function (tagName, attrs, children) {\n        const component = components[tagName];\n\n        const node = component ? component(attrs, children) : h(tagName, attrs, children);\n\n        return node;\n    };\n\n    const hx = domBuilder(eh);\n\n    hx.h = eh;\n\n    return hx;\n};\n","module.exports = attributeToProperty\n\nvar transform = {\n  'class': 'className',\n  'for': 'htmlFor',\n  'http-equiv': 'httpEquiv'\n}\n\nfunction attributeToProperty (h) {\n  return function (tagName, attrs, children) {\n    for (var attr in attrs) {\n      if (attr in transform) {\n        attrs[transform[attr]] = attrs[attr]\n        delete attrs[attr]\n      }\n    }\n    return h(tagName, attrs, children)\n  }\n}\n","const attrToProp = require('hyperscript-attribute-to-property')\n\nconst VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4,\n      ATTR_KEY = 5, ATTR_KEY_W = 6,\n      ATTR_VALUE_W = 7, ATTR_VALUE = 8,\n      ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10,\n      ATTR_EQ = 11, ATTR_BREAK = 12,\n      COMMENT = 13, SELF_CLOSE = 14\n\nmodule.exports = function (h, opts) {\n  if (!opts) opts = {\n    comments: true\n  }\n  const concat = opts.concat || function (a, b) {\n    return String(a) + String(b)\n  }\n\n  const strfn = (x) => {\n    switch (typeof x) {\n      case 'function':\n      case 'string':\n      case 'object':\n      case 'undefined':\n        return x\n      default:\n        return concat('', x)\n    }\n  }\n\n  if (opts.attrToProp !== false) {\n    h = attrToProp(h)\n  }\n\n  return function (strings) {\n    var state = TEXT, reg = ''\n    var arglen = arguments.length\n    var parts = []\n\n    for (var i = 0; i < strings.length; i++) {\n      if (i < arglen - 1) {\n        var arg = arguments[i+1]\n        var p = parse(strings[i])\n        var xstate = state\n        switch (xstate) {\n          case COMMENT:\n            reg+=arg\n            arg = ''\n          case ATTR_VALUE_DQ:\n          case ATTR_VALUE_SQ:\n          case ATTR_VALUE_W:\n            xstate = ATTR_VALUE\n            break\n          case ATTR:\n            xstate = ATTR_KEY\n            break\n        }\n        p.push([ VAR, xstate, arg ])\n        parts.push.apply(parts, p)\n      } else parts.push.apply(parts, parse(strings[i]))\n    }\n\n    var tree = [null,{},[]]\n    var stack = [[tree,-1]]\n    for (var i = 0; i < parts.length; i++) {\n      var cur = stack[stack.length-1][0]\n      var p = parts[i], s = p[0]\n      if (s === OPEN && /^\\//.test(p[1])) {\n        var ix = stack[stack.length-1][1]\n        if (stack.length > 1) {\n          stack.pop()\n          stack[stack.length-1][0][2][ix] = h(\n            cur[0], cur[1], cur[2].length ? cur[2] : undefined\n          )\n        }\n      } else if (s === OPEN) {\n        var c = [p[1],{},[]]\n        cur[2].push(c)\n        stack.push([c,cur[2].length-1])\n      } else if (s === ATTR_KEY || (s === VAR && p[1] === ATTR_KEY)) {\n        var key = ''\n        var copyKey\n        for (; i < parts.length; i++) {\n          if (parts[i][0] === ATTR_KEY) {\n            key = concat(key, parts[i][1])\n          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {\n            if (typeof parts[i][2] === 'object' && !key) {\n              for (copyKey in parts[i][2]) {\n                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {\n                  cur[1][copyKey] = parts[i][2][copyKey]\n                }\n              }\n            } else {\n              key = concat(key, parts[i][2])\n            }\n          } else break\n        }\n        if (parts[i][0] === ATTR_EQ) i++\n        var j = i\n        for (; i < parts.length; i++) {\n          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {\n            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])\n            else parts[i][1]===\"\" || (cur[1][key] = concat(cur[1][key], parts[i][1]));\n          } else if (parts[i][0] === VAR\n          && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {\n            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])\n            else parts[i][2]===\"\" || (cur[1][key] = concat(cur[1][key], parts[i][2]));\n          } else {\n            if (key.length && !cur[1][key] && i === j\n            && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {\n              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes\n              // empty string is falsy, not well behaved value in browser\n              cur[1][key] = key.toLowerCase()\n            }\n            if (parts[i][0] === CLOSE) {\n              i--\n            }\n            break\n          }\n        }\n      } else if (s === SELF_CLOSE) {\n        var ix = stack[stack.length-1][1]\n        stack.pop()\n        stack[stack.length-1][0][2][ix] = h(\n          cur[0], cur[1], cur[2].length ? cur[2] : undefined\n        )\n      } else if (s === VAR && p[1] === TEXT) {\n        if (p[2] === undefined || p[2] === null) p[2] = ''\n        else if (!p[2]) p[2] = concat('', p[2])\n        if (Array.isArray(p[2][0])) {\n          cur[2].push.apply(cur[2], p[2])\n        } else {\n          cur[2].push(p[2])\n        }\n      } else if (s === TEXT) {\n        cur[2].push(p[1])\n      } else if (s === ATTR_EQ || s === ATTR_BREAK || s === CLOSE) {\n        // no-op\n      } else {\n        throw new Error('unhandled: ' + s)\n      }\n    }\n\n    if (tree[2].length > 1 && /^\\s*$/.test(tree[2][0])) {\n      tree[2].shift()\n    }\n\n    if (tree[2].length > 2\n    || (tree[2].length === 2 && /\\S/.test(tree[2][1]))) {\n      throw new Error(\n        'multiple root elements must be wrapped in an enclosing tag'\n      )\n    }\n    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string'\n    && Array.isArray(tree[2][0][2])) {\n      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])\n    }\n    return tree[2][0]\n\n    function parse (str) {\n      var res = []\n      if (state === ATTR_VALUE_W) state = ATTR\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i)\n        if (state === COMMENT) {\n          // ignore until we get to close comment\n          if (/-$/.test(reg) && c === '-') {\n            if (opts.comments) {\n              res.push([ATTR_VALUE,reg.substr(0, reg.length - 1)],[CLOSE])\n            }\n            reg = ''\n            state = TEXT\n          }\n          else {\n            reg += c\n            continue\n          }\n        }\n        if (state === TEXT && c === '<') {\n          if (reg.length) res.push([TEXT, reg])\n          reg = ''\n          state = OPEN\n        } else if (c === '>' && str.charAt(i - 1) === '/') {\n          res.push([SELF_CLOSE])\n          reg = ''\n          state = TEXT\n        } else if (c === '>' && str.charAt(i - 1) === '-' && str.charAt(i - 2) === '-') {\n          res.push([SELF_CLOSE])\n          reg = ''\n          state = TEXT\n        } else if (c === '>' && !quot(state) && state !== COMMENT) {\n          if (state === OPEN) {\n            res.push([OPEN,reg])\n          } else if (state === ATTR_KEY) {\n            res.push([ATTR_KEY,reg])\n          } else if (state === ATTR_VALUE && reg.length) {\n            res.push([ATTR_VALUE,reg])\n          }\n          res.push([CLOSE])\n          reg = ''\n          state = TEXT\n        } else if (state === OPEN && /^!--$/.test(reg)) {\n          if (opts.comments) {\n            res.push([OPEN, reg],[ATTR_KEY,'comment'],[ATTR_EQ])\n          }\n          reg = c\n          state = COMMENT\n        } else if (state === TEXT) {\n          reg += c\n        } else if (state === OPEN && c === '/' && reg.length) {\n          res.push([OPEN, reg])\n          reg = ''\n          state = TEXT\n        } else if (state === OPEN && /\\s/.test(c)) {\n          res.push([OPEN, reg])\n          reg = ''\n          state = ATTR\n        } else if (state === OPEN) {\n          reg += c\n        } else if (state === ATTR && /[^\\s\"'=/]/.test(c)) {\n          state = ATTR_KEY\n          reg = c\n        } else if (state === ATTR && /\\s/.test(c)) {\n          if (reg.length) res.push([ATTR_KEY,reg])\n          res.push([ATTR_BREAK])\n        } else if (state === ATTR_KEY && /\\s/.test(c)) {\n          res.push([ATTR_KEY,reg])\n          reg = ''\n          state = ATTR_KEY_W\n        } else if (state === ATTR_KEY && c === '=') {\n          res.push([ATTR_KEY,reg],[ATTR_EQ])\n          reg = ''\n          state = ATTR_VALUE_W\n        } else if (state === ATTR_KEY) {\n          reg += c\n        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {\n          res.push([ATTR_EQ])\n          state = ATTR_VALUE_W\n        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\\s/.test(c)) {\n          res.push([ATTR_BREAK])\n          if (/[\\w-]/.test(c)) {\n            reg += c\n            state = ATTR_KEY\n          } else state = ATTR\n        } else if (state === ATTR_VALUE_W && c === '\"') {\n          state = ATTR_VALUE_DQ\n        } else if (state === ATTR_VALUE_W && c === \"'\") {\n          state = ATTR_VALUE_SQ\n        } else if (state === ATTR_VALUE_DQ && c === '\"') {\n          res.push([ATTR_VALUE,reg],[ATTR_BREAK])\n          reg = ''\n          state = ATTR\n        } else if (state === ATTR_VALUE_SQ && c === \"'\") {\n          res.push([ATTR_VALUE,reg],[ATTR_BREAK])\n          reg = ''\n          state = ATTR\n        } else if (state === ATTR_VALUE_W && !/\\s/.test(c)) {\n          state = ATTR_VALUE\n          i--\n        } else if (state === ATTR_VALUE && /\\s/.test(c)) {\n          res.push([ATTR_VALUE,reg],[ATTR_BREAK])\n          reg = ''\n          state = ATTR\n        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ\n        || state === ATTR_VALUE_DQ) {\n          reg += c\n        }\n      }\n      if (reg.length) {\n        switch (state) {\n          case TEXT:\n            res.push([TEXT,reg])\n            reg = ''\n            break\n          case ATTR_VALUE:\n          case ATTR_VALUE_DQ:\n          case ATTR_VALUE_SQ:\n            res.push([ATTR_VALUE,reg])\n            reg = ''\n            break\n        }\n      }\n      if (state === ATTR_KEY) {\n        res.push([ATTR_KEY,reg])\n        reg = ''\n      }\n      return res\n    }\n  }\n}\n\nconst quot = (state) =>\n  state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ\n","const nanohtml = require('@tram-one/nanohtml');\nconst rbel = require('@tram-one/rbel');\nconst hyperx = require('@tram-one/hyperx');\n\nimport { TRAM_HOOK_KEY } from './engine-names';\nimport {\n\tpushWorkingKeyBranch,\n\tpopWorkingKeyBranch,\n\tincrementWorkingKeyBranch,\n\tcopyWorkingKey,\n\trestoreWorkingKey,\n} from './working-key';\nimport observeTag from './observe-tag';\nimport processHooks from './process-hooks';\nimport { TRAM_TAG, TRAM_TAG_NEW_EFFECTS, TRAM_TAG_CLEANUP_EFFECTS } from './node-names';\n\nimport { Registry, Props, DOMTaggedTemplateFunction, Children } from './types';\n\n/**\n * This function takes in a namespace and registry of custom components,\n * and builds a `dom` template tag function that can take in a template XML string.\n *\n * This function shouldn't need to be called directly, instead, you can use `registerHtml` or `registerSvg`\n *\n * @param registry mapping of tag names to component functions\n * @param namespace namespace to create nodes in (by default XHTML namespace)\n */\nexport const registerDom = (namespace: string | null, registry: Registry = {}): DOMTaggedTemplateFunction => {\n\t// modify the registry so that each component function updates the hook working key\n\tconst hookedRegistry = Object.keys(registry).reduce((newRegistry, tagName) => {\n\t\tconst tagFunction = registry[tagName];\n\t\tconst hookedTagFunction = (props: Props, children: Children) => {\n\t\t\t// push a new branch onto the working key so any values that need to be unique among components\n\t\t\t// but consistent across renders can be read\n\t\t\tconst stringifiedProps = JSON.stringify(props);\n\t\t\tconst newBranch = `${tagName}[${stringifiedProps}]`;\n\t\t\tpushWorkingKeyBranch(TRAM_HOOK_KEY, newBranch);\n\n\t\t\t// increment branch so that we have a unique value (in case we are rendering a list of components)\n\t\t\tincrementWorkingKeyBranch(TRAM_HOOK_KEY);\n\t\t\tconst uniqueBranch = copyWorkingKey(TRAM_HOOK_KEY);\n\n\t\t\t// create a tag function that has the args passed in\n\t\t\tconst populatedTagFunction = () => {\n\t\t\t\t// reset working key so we have the correct place when starting a new component\n\t\t\t\trestoreWorkingKey(TRAM_HOOK_KEY, uniqueBranch);\n\n\t\t\t\treturn tagFunction(props, children);\n\t\t\t};\n\n\t\t\t// observe store usage and process any new effects that were called when building the component\n\t\t\tconst processHooksAndBuildTagResult = () => processHooks(populatedTagFunction);\n\t\t\tconst tagResult = observeTag(processHooksAndBuildTagResult);\n\n\t\t\t// pop the branch off (since we are done rendering this component)\n\t\t\tpopWorkingKeyBranch(TRAM_HOOK_KEY);\n\n\t\t\t// decorate the properties expected on TramOneElements (see node-names.ts)\n\t\t\ttagResult[TRAM_TAG] = true;\n\t\t\t// we won't decorate TRAM_TAG_REACTION, that needs to be done later when we observe the tag\n\t\t\ttagResult[TRAM_TAG_NEW_EFFECTS] = tagResult[TRAM_TAG_NEW_EFFECTS] || [];\n\t\t\ttagResult[TRAM_TAG_CLEANUP_EFFECTS] = tagResult[TRAM_TAG_NEW_EFFECTS] || [];\n\n\t\t\treturn tagResult;\n\t\t};\n\n\t\treturn { ...newRegistry, [tagName]: hookedTagFunction };\n\t}, {});\n\n\treturn rbel(hyperx, nanohtml(namespace), hookedRegistry);\n};\n","import { registerDom } from './dom';\n\nimport { Registry } from './types';\n\n/**\n * @name registerHtml\n * @link https://tram-one.io/#register-html\n * @description\n * Function to generate a tagged template function for XHTML / HTML.\n * Takes in a registry that allows you to import other tag functions and use them in your template string.\n *\n * @param registry map of tag names to functions, use this to use custom elements built in tram-one\n * @return tagged template function that builds HTML components\n */\nexport const registerHtml = (registry?: Registry) => {\n\treturn registerDom(null, registry);\n};\n\n/**\n * @name registerSvg\n * @link https://tram-one.io/#register-svg\n * @description\n * Function to generate a tagged template function for SVG.\n *\n * @param registry map of tag names to functions, use this to use custom elements built in tram-one\n * @return tagged template function that builds SVG components\n */\nexport const registerSvg = (registry?: Registry) => {\n\treturn registerDom('http://www.w3.org/2000/svg', registry);\n};\n","import { TRAM_HOOK_KEY, TRAM_EFFECT_QUEUE } from './engine-names';\nimport { getEffectStore } from './effect-store';\nimport { getWorkingKeyValue, incrementWorkingKeyBranch } from './working-key';\n\nimport { Effect } from './types';\n\n/**\n * @name useEffect\n * @link https://tram-one.io/#use-effect\n * @description\n * Hook that triggers component start, update, and cleanup effects.\n * If the return of effect is another function, then that function is called on when the component is removed.\n * If the effect is dependent on a observable, it will automatically trigger again if that value updates.\n *\n * @param effect function to run on component mount\n */\nexport default (effect: Effect): void => {\n\t// get the store of effects\n\tconst effectQueue = getEffectStore(TRAM_EFFECT_QUEUE);\n\n\t// get the key value from working-key\n\tconst key = getWorkingKeyValue(TRAM_HOOK_KEY);\n\n\t// increment the working key branch value\n\t// this makes successive useEffects calls unique (until we reset the key)\n\tincrementWorkingKeyBranch(TRAM_HOOK_KEY);\n\n\t// append () so that it's easier to debug effects from components\n\tconst callLikeKey = `${key}()`;\n\n\t// add the effect to the effect queue, so it can be processed later\n\teffectQueue[callLikeKey] = effect;\n};\n","const { observable } = require('@nx-js/observer-util');\n\nimport { buildNamespace } from './namespace';\n\n/*\n * Observable Stores in Tram-One are used for objects whose properties need to be observed.\n * This stores the values in the useStore and useGlobalStore hooks, internally tracking\n * them as proxies, and making observed functions respond to their changes.\n */\n\nexport const { setup: setupObservableStore, get: getObservableStore } = buildNamespace(() => observable({}));\n","// This library started as an experiment to see how small I could make\n// a functional router. It has since been optimized (and thus grown).\n// The redundancy and inelegance here is for the sake of either size\n// or speed.\n//\n// That's why router params are marked with a single char: `~` and named params are denoted `:`\n(function (root, factory) {\n  var define = root && root.define;\n\n  if (define && define.amd) {\n    define('rlite', [], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Rlite = factory();\n  }\n}(this, function () {\n  return function (notFound, routeDefinitions) {\n    var routes = {};\n    var decode = decodeURIComponent;\n\n    init();\n\n    return run;\n\n    function init() {\n      for (var key in routeDefinitions) {\n        add(key, routeDefinitions[key]);\n      }\n    };\n\n    function noop(s) { return s; }\n\n    function sanitize(url) {\n      ~url.indexOf('/?') && (url = url.replace('/?', '?'));\n      url[0] == '/' && (url = url.slice(1));\n      url[url.length - 1] == '/' && (url = url.slice(0, -1));\n\n      return url;\n    }\n\n    // Recursively searches the route tree for a matching route\n    // pieces: an array of url parts, ['users', '1', 'edit']\n    // esc: the function used to url escape values\n    // i: the index of the piece being processed\n    // rules: the route tree\n    // params: the computed route parameters (this is mutated), and is a stack since we don't have fast immutable datatypes\n    //\n    // This attempts to match the most specific route, but may end int a dead-end. We then attempt a less specific\n    // route, following named route parameters. In searching this secondary branch, we need to make sure to clear\n    // any route params that were generated during the search of the dead-end branch.\n    function recurseUrl(pieces, esc, i, rules, params) {\n      if (!rules) {\n        return;\n      }\n\n      if (i >= pieces.length) {\n        var cb = rules['@'];\n        return cb && {\n          cb: cb,\n          params: params.reduce(function(h, kv) { h[kv[0]] = kv[1]; return h; }, {}),\n        };\n      }\n\n      var piece = esc(pieces[i]);\n      var paramLen = params.length;\n      return recurseUrl(pieces, esc, i + 1, rules[piece.toLowerCase()], params)\n        || recurseNamedUrl(pieces, esc, i + 1, rules, ':', piece, params, paramLen)\n        || recurseNamedUrl(pieces, esc, pieces.length, rules, '*', pieces.slice(i).join('/'), params, paramLen);\n    }\n\n    // Recurses for a named route, where the name is looked up via key and associated with val\n    function recurseNamedUrl(pieces, esc, i, rules, key, val, params, paramLen) {\n      params.length = paramLen; // Reset any params generated in the unsuccessful search branch\n      var subRules = rules[key];\n      subRules && params.push([subRules['~'], val]);\n      return recurseUrl(pieces, esc, i, subRules, params);\n    }\n\n    function processQuery(url, ctx, esc) {\n      if (url && ctx.cb) {\n        var hash = url.indexOf('#'),\n            query = (hash < 0 ? url : url.slice(0, hash)).split('&');\n\n        for (var i = 0; i < query.length; ++i) {\n          var nameValue = query[i].split('=');\n\n          ctx.params[nameValue[0]] = esc(nameValue[1]);\n        }\n      }\n\n      return ctx;\n    }\n\n    function lookup(url) {\n      var querySplit = sanitize(url).split('?');\n      var esc = ~url.indexOf('%') ? decode : noop;\n\n      return processQuery(querySplit[1], recurseUrl(querySplit[0].split('/'), esc, 0, routes, []) || {}, esc);\n    }\n\n    function add(route, handler) {\n      var pieces = route.split('/');\n      var rules = routes;\n\n      for (var i = +(route[0] === '/'); i < pieces.length; ++i) {\n        var piece = pieces[i];\n        var name = piece[0] == ':' ? ':' : piece[0] == '*' ? '*' : piece.toLowerCase();\n\n        rules = rules[name] || (rules[name] = {});\n\n        (name == ':' || name == '*') && (rules['~'] = piece.slice(1));\n      }\n\n      rules['@'] = handler;\n    }\n\n    function run(url, arg) {\n      var result = lookup(url);\n\n      return (result.cb || notFound)(result.params, arg, url);\n    };\n  };\n}));\n","const rlite = require('rlite-router')\n\nconst onNonMatchingPath = () => ({ matches: false })\nconst returnParams = params => ({ matches: true, ...params })\n\nmodule.exports = (getPath) => (pattern = '*') => rlite(onNonMatchingPath, { [pattern]: returnParams })(getPath())\n","const urlParamHook = require('./urlParamHook')\n\n/**\n * @see https://tram-one.io/api/#Tram-One#useUrlParams\n * @name useUrlParams\n *\n * @param {function} [getPath] - function to return the current path, defaults to reading window.location.href\n * @returns the useUrlParams hook\n */\nmodule.exports = urlParamHook\n","const urlParamHook = require('./urlParamHook')\n\nconst defaultGetPath = () => window.location.href.replace(window.location.origin, '')\n\n/**\n * @see https://tram-one.io/api/#Tram-One#useUrlParams\n *\n * @description\n * Hook that returns path variables based on the route.\n * Can return path parameters, query params, and more.\n * It's internal functionality is powered by the package\n * {@link https://www.npmjs.com/package/rlite-router | rlite}\n *\n * Rather than using XML templates to define routes, this method enables\n * routing in javascript.\n *\n * @param {String} [pattern] path for resolving path parameters (not required for query params)\n *\n * @returns {Object} object with a `matches` key, and (if it matched) path and query parameters\n */\nmodule.exports = urlParamHook(defaultGetPath)\n","const setupUrlParams = require('./setupUrlParams')\nconst useUrlParams = require('./useUrlParams')\n\nmodule.exports = useUrlParams\nuseUrlParams.setupUrlParams = setupUrlParams\nuseUrlParams.useUrlParams = useUrlParams\n","import { Container, ElementOrSelector } from './types';\n\n/**\n * Helper function for getting an element when given a string or element\n * @param target either a CSS selector, or Element to attach the component to.\n * @returns the container that we can mount on\n */\nconst getContainerElement = (target: ElementOrSelector): Element => {\n\t// if the selector is a string, try to find the element,\n\t// otherwise it's probably DOM that we should write directly to\n\tif (typeof target === 'string') {\n\t\tconst selectedElement = document.querySelector(target);\n\t\tif (selectedElement === null) {\n\t\t\tthrow new Error(`\n\t\t\t\tTram-One: could not find target, is the element on the page yet?\n\t\t\t\thttps://github.com/Tram-One/tram-one/issues/179\n\t\t\t`);\n\t\t}\n\t\treturn selectedElement;\n\t} else {\n\t\treturn target;\n\t}\n};\n\n/**\n * Function to determine (or create) the element that we will mount our tram-one app onto\n * @param target either a CSS selector, or Element to attach the component to.\n * This elememnt should be initially empty.\n *\n * @returns the container, now with a div that tram-one can manage\n */\nexport default (target: ElementOrSelector): Container => {\n\tconst container = getContainerElement(target);\n\n\t// build a div to render the app on\n\t// - if it doesn't exist as a child of the selector, create one first\n\tif (!container.firstElementChild) {\n\t\tconst containerChild = document.createElement('div');\n\t\tcontainer.appendChild(containerChild);\n\t}\n\n\treturn container as Container;\n};\n","/*\n * The KeyStore in Tram-One is a basic key-value object\n * that needs to be persisted in the globalSpace.\n *\n * Currently this is used with useStore and useGlobalStore to keep\n * track of what stores need to be cleaned up when removing elements\n */\n\nimport { buildNamespace } from './namespace';\nimport { KeyObservers } from './types';\n\nconst newDefaultKeyStore = () => {\n\treturn {} as KeyObservers;\n};\n\nexport const { setup: setupKeyStore, get: getKeyStore, set: setKeyStore } = buildNamespace(newDefaultKeyStore);\n\n/**\n * increment (or set initial value) for the keyStore\n */\nexport const incrementKeyStoreValue = (keyStoreName: string, key: string) => {\n\tconst keyStore = getKeyStore(keyStoreName);\n\tkeyStore[key] = keyStore[key] + 1 || 1;\n};\n\n/**\n * decrement a value in the keyStore\n */\nexport const decrementKeyStoreValue = (keyStoreName: string, key: string) => {\n\tconst keyStore = getKeyStore(keyStoreName);\n\tkeyStore[key]--;\n};\n","/*\n * The mutation-observer is a global instance of browsers MutationObserver\n * which tracks when nodes are added or removed.\n *\n * When nodes are added we process their effects. When nodes are removed we process any cleanup,\n * and stop observers that would trigger for that node.\n */\n\nconst { observe, unobserve } = require('@nx-js/observer-util');\n\nimport {\n\tTRAM_TAG,\n\tTRAM_TAG_REACTION,\n\tTRAM_TAG_NEW_EFFECTS,\n\tTRAM_TAG_CLEANUP_EFFECTS,\n\tTRAM_TAG_STORE_KEYS,\n} from './node-names';\nimport { buildNamespace } from './namespace';\nimport { TramOneElement } from './types';\nimport { getObservableStore } from './observable-store';\nimport { TRAM_OBSERVABLE_STORE, TRAM_KEY_STORE } from './engine-names';\nimport { decrementKeyStoreValue, getKeyStore, incrementKeyStoreValue } from './key-store';\n\n/**\n * process side-effects for new tram-one nodes\n * (this includes calling effects, and keeping track of stores)\n */\nconst processTramTags = (node: Node | TramOneElement) => {\n\t// if this element doesn't have a TRAM_TAG, it's not a Tram-One Element\n\tif (!(TRAM_TAG in node)) {\n\t\treturn;\n\t}\n\n\tconst hasStoreKeys = node[TRAM_TAG_STORE_KEYS];\n\n\tif (hasStoreKeys) {\n\t\t// for every store associated with this element, increment the count\n\t\t// - this ensures that it doesn't get blown away when we clean up old stores\n\t\tnode[TRAM_TAG_STORE_KEYS].forEach((key) => {\n\t\t\tincrementKeyStoreValue(TRAM_KEY_STORE, key);\n\t\t});\n\t}\n\n\tconst hasEffects = node[TRAM_TAG_NEW_EFFECTS];\n\n\tif (hasEffects) {\n\t\t// create an array for the cleanup effects\n\t\tnode[TRAM_TAG_CLEANUP_EFFECTS] = [];\n\n\t\t// run all the effects, saving any cleanup functions to the node\n\t\tnode[TRAM_TAG_NEW_EFFECTS].forEach((effect) => {\n\t\t\tlet cleanup: unknown;\n\n\t\t\t// this is called when an effect is re-triggered\n\t\t\tconst effectReaction = observe(() => {\n\t\t\t\t// verify that cleanup is a function before calling it (in case it was a promise)\n\t\t\t\tif (typeof cleanup === 'function') cleanup();\n\t\t\t\tcleanup = effect();\n\t\t\t});\n\n\t\t\t// this is called when a component with an effect is removed\n\t\t\tconst totalCleanup = () => {\n\t\t\t\t// verify that cleanup is a function before calling it (in case it was a promise)\n\t\t\t\tif (typeof cleanup === 'function') cleanup();\n\t\t\t\tunobserve(effectReaction);\n\t\t\t};\n\n\t\t\tnode[TRAM_TAG_CLEANUP_EFFECTS].push(totalCleanup);\n\t\t});\n\n\t\t// set new tag effects to an empty array\n\t\tnode[TRAM_TAG_NEW_EFFECTS] = [];\n\t}\n};\n\n/**\n * call all cleanup effects on the node\n */\nconst cleanupEffects = (cleanupEffects: (() => void)[]) => {\n\tcleanupEffects.forEach((cleanup) => cleanup());\n};\n\n/**\n * remove the association of the store with this specific element\n */\nconst removeStoreKeyAssociation = (storeKeys: string[]) => {\n\tstoreKeys.forEach((storeKey) => {\n\t\tdecrementKeyStoreValue(TRAM_KEY_STORE, storeKey);\n\t});\n};\n\n/**\n * remove any stores that no longer have any elements associated with them\n * see removeStoreKeyAssociation above\n */\nconst cleanUpObservableStores = () => {\n\tconst observableStore = getObservableStore(TRAM_OBSERVABLE_STORE);\n\tconst keyStore = getKeyStore(TRAM_KEY_STORE);\n\tObject.entries(keyStore).forEach(([key, observers]) => {\n\t\tif (observers === 0) {\n\t\t\tdelete observableStore[key];\n\t\t\tdelete keyStore[key];\n\t\t}\n\t});\n};\n\n/**\n * unobserve the reaction tied to the node, and run all cleanup effects for the node\n */\nconst clearNode = (node: Node | TramOneElement) => {\n\t// if this element doesn't have a TRAM_TAG, it's not a Tram-One Element\n\tif (!(TRAM_TAG in node)) {\n\t\treturn;\n\t}\n\n\tunobserve(node[TRAM_TAG_REACTION]);\n\tcleanupEffects(node[TRAM_TAG_CLEANUP_EFFECTS]);\n\tremoveStoreKeyAssociation(node[TRAM_TAG_STORE_KEYS]);\n};\n\nconst isTramOneComponent = (node: Node | TramOneElement) => {\n\t// a node is a component if it has `TRAM_TAG` key on it\n\tconst nodeIsATramOneComponent = TRAM_TAG in node;\n\t// if it is a tram-one component, we want to process it, otherwise skip it\n\treturn nodeIsATramOneComponent ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n};\n\n/**\n * function to get the children (as a list) of the node passed in\n */\nconst childrenComponents = (node: Node | TramOneElement) => {\n\tconst componentWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, isTramOneComponent);\n\tconst children = [];\n\twhile (componentWalker.nextNode()) {\n\t\tchildren.push(componentWalker.currentNode);\n\t}\n\n\treturn children;\n};\n\nconst mutationObserverNamespaceConstructor = () =>\n\tnew MutationObserver((mutationList) => {\n\t\t// cleanup orphaned nodes that are no longer on the DOM\n\t\tconst removedNodesInMutation = (mutation: MutationRecord) => [...mutation.removedNodes];\n\t\tconst removedNodes = mutationList.flatMap(removedNodesInMutation);\n\t\tconst removedChildNodes = removedNodes.flatMap(childrenComponents);\n\n\t\tremovedChildNodes.forEach(clearNode);\n\n\t\t// call new effects on any new nodes\n\t\tconst addedNodesInMutation = (mutation: MutationRecord) => [...mutation.addedNodes];\n\t\tconst newNodes = mutationList.flatMap(addedNodesInMutation);\n\t\tconst newChildNodes = newNodes.flatMap(childrenComponents);\n\n\t\tnewChildNodes.forEach(processTramTags);\n\n\t\t// clean up all local observable stores that have no observers\n\t\tcleanUpObservableStores();\n\t});\n\nexport const { setup: setupMutationObserver, get: getMutationObserver } = buildNamespace(\n\tmutationObserverNamespaceConstructor\n);\n\n// tell the mutation observer to watch the given node for changes\nexport const startWatcher = (observerName: string, node: Element) => {\n\tconst observerStore = getMutationObserver(observerName);\n\n\tobserverStore.observe(node, { childList: true, subtree: true });\n};\n","import logoSVG from \"bundle-text:../logo.svg\";\n\nconst element = document.createElement(\"div\");\nelement.innerHTML = logoSVG;\nexport default element.querySelector(\"svg\");\n","module.exports = \"8e8a8564add21c26\";","import { registerHtml, TramOneComponent } from \"tram-one\";\nimport logo from \"@tram-one/tram-logo/dist/element\";\nimport \"./app.css\";\n\nconst html = registerHtml();\n\nconst app: TramOneComponent = () => {\n  return html`\n    <main class=\"app\">\n      ${logo}\n      <p>Update '<code>src/app.js</code>' to see changes!</p>\n      <a href=\"https://tram-one.io\" target=\"_blank\"> Learn Tram-One </a>\n    </main>\n  `;\n};\n\nexport default app;\n","import mount from './mount';\nimport buildContainer from './build-mounting-container';\nimport {\n\tTRAM_EFFECT_STORE,\n\tTRAM_HOOK_KEY,\n\tTRAM_EFFECT_QUEUE,\n\tTRAM_OBSERVABLE_STORE,\n\tTRAM_MUTATION_OBSERVER,\n\tTRAM_KEY_QUEUE,\n\tTRAM_KEY_STORE,\n} from './engine-names';\nimport { setupTramOneSpace } from './namespace';\nimport { setupEffectStore } from './effect-store';\nimport { setupWorkingKey } from './working-key';\nimport { setupObservableStore } from './observable-store';\nimport { setupMutationObserver, startWatcher } from './mutation-observer';\nimport { ElementOrSelector, RootTramOneComponent } from './types';\nimport { setupKeyQueue } from './key-queue';\nimport { setupKeyStore } from './key-store';\n\n/**\n * @name start\n * @link https://tram-one.io/#start\n * @description\n * Function to attach a component to an existing element on the page.\n * This function also starts all the listeners and allows the basic hooks to function.\n *\n * This should only be called for the initial render / building of the app.\n *\n * @param component top-level component to attach to the page.\n * @param target either a CSS selector, or Node to attach the component to\n */\nexport default (component: RootTramOneComponent, target: ElementOrSelector) => {\n\t/* setup all the internal engines required for tram-one to work */\n\n\t// get the container to mount the app on\n\tconst container = buildContainer(target);\n\n\t// setup the window object to hold stores and queues\n\t// in the future, we may allow this to be customized\n\t// for multiple, sandboxed, instances of Tram-One\n\tsetupTramOneSpace();\n\n\t// setup store for effects\n\tsetupEffectStore(TRAM_EFFECT_STORE);\n\n\t// setup queue for new effects when resolving mounts\n\tsetupEffectStore(TRAM_EFFECT_QUEUE);\n\n\t// setup working key for hooks\n\tsetupWorkingKey(TRAM_HOOK_KEY);\n\n\t// setup observable store for the useStore and useGlobalStore hooks\n\tsetupObservableStore(TRAM_OBSERVABLE_STORE);\n\n\t// setup key store for keeping track of stores to clean up\n\tsetupKeyStore(TRAM_KEY_STORE);\n\n\t// setup key queue for new observable stores when resolving mounts\n\tsetupKeyQueue(TRAM_KEY_QUEUE);\n\n\t// setup a mutation observer for cleaning up removed elements and triggering effects\n\tsetupMutationObserver(TRAM_MUTATION_OBSERVER);\n\n\t// watch for changes on the target so that we can process node changes\n\tstartWatcher(TRAM_MUTATION_OBSERVER, container);\n\n\t// trigger an initial mount\n\tmount(component, container);\n};\n","import { registerHtml } from './dom-wrappers';\nimport { Container, RootTramOneComponent } from './types';\n\n/**\n * Updates a container with an initial component for the first render.\n * @param component the tram-one component to render\n * @param container an element to render the component on\n */\nexport default (component: RootTramOneComponent, container: Container) => {\n\tconst html = registerHtml({\n\t\tapp: component,\n\t});\n\n\t// this sadly needs to be wrapped in some element so we can process effects\n\t// otherwise the root node will not have effects applied on it\n\tconst renderedApp = html`<div><app /></div>`;\n\tcontainer.replaceChild(renderedApp, container.firstElementChild);\n};\n","import { start } from \"tram-one\";\nimport app from \"./app\";\nimport \"./index.css\";\n\nstart(app, \"#root\");\n"],"names":["$2e682f50ad48c6fc$var$getTramWindow","window","Error","$2e682f50ad48c6fc$var$buildNamespace","constructor","namespace","tramWindow","value","setup","$2e682f50ad48c6fc$var$setupWorkingKey","get","$2e682f50ad48c6fc$var$getWorkingKey","branch","branchIndices","$2e682f50ad48c6fc$var$getWorkingBranch","keyName","join","$2e682f50ad48c6fc$var$incrementWorkingKeyBranch","$1682bfda3685e13f$var$connectionStore","WeakMap","$1682bfda3685e13f$var$ITERATION_KEY","Symbol","$1682bfda3685e13f$var$addReactionsForKey","reactionsForKey","reactionsForTarget","key","reactions","forEach","add","$1682bfda3685e13f$var$releaseReaction","reaction","cleaners","$1682bfda3685e13f$var$releaseReactionKeyConnection","delete","this","$1682bfda3685e13f$var$reactionStack","$1682bfda3685e13f$var$isDebugging","$1682bfda3685e13f$var$runAsReaction","fn","context","args","unobserved","Reflect","apply","indexOf","push","pop","$1682bfda3685e13f$var$registerRunningReactionForOperation","operation","runningReaction","length","$1682bfda3685e13f$var$debugOperation","ref","target1","target","type","reactionsForObj","Set","set","has","$1682bfda3685e13f$var$registerReactionForOperation","$1682bfda3685e13f$var$queueReactionsForOperation","target2","key1","_","iterationKey","Array","isArray","$1682bfda3685e13f$var$getReactionsForOperation","$1682bfda3685e13f$var$queueReaction","scheduler","debugger","$1682bfda3685e13f$var$hasRunningReaction","$1682bfda3685e13f$var$IS_REACTION","$1682bfda3685e13f$export$d1203567a167490e","options","reaction1","arguments","lazy","$1682bfda3685e13f$var$proxyToRaw","$1682bfda3685e13f$var$rawToProxy","$1682bfda3685e13f$var$hasOwnProperty","Object","prototype","hasOwnProperty","$1682bfda3685e13f$var$findObservable","obj","observableObj","$1682bfda3685e13f$export$5ab46cbf6120b33a","$1682bfda3685e13f$var$patchIterator","iterator","isEntries","originalNext","next","call","done","$1682bfda3685e13f$var$instrumentations","target3","proto1","getPrototypeOf","target4","proto2","target5","proto3","hadKey","result","target6","proto4","oldValue","target7","proto5","undefined","clear","target8","proto6","hadItems","size","oldTarget","Map","cb","len1","target9","proto7","wrappedCb","rest","len","concat","keys","target10","proto8","values","target11","proto9","entries","target12","proto10","proto","$1682bfda3685e13f$var$collectionHandlers","receiver","$1682bfda3685e13f$var$globalObj","Function","$1682bfda3685e13f$var$handlers","WeakSet","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","$1682bfda3685e13f$var$hasOwnProperty$1","$1682bfda3685e13f$var$wellKnownSymbols","getOwnPropertyNames","map","filter","$1682bfda3685e13f$var$baseHandlers","observableResult","descriptor","getOwnPropertyDescriptor","writable","configurable","ownKeys","deleteProperty","name","handlers1","$1682bfda3685e13f$var$getHandlers","observable1","Proxy","$1682bfda3685e13f$var$storeObservable","$1682bfda3685e13f$var$createObservable","$2e682f50ad48c6fc$var$toIndices","node","index","$2e682f50ad48c6fc$var$parentAndChildrenElements","tagName","matchesTagName","NodeFilter","FILTER_ACCEPT","FILTER_SKIP","$2e682f50ad48c6fc$var$hasMatchingTagName","componentWalker","document","createTreeWalker","SHOW_ELEMENT","parentAndChildren","currentNode","nextNode","$2e682f50ad48c6fc$var$defaultRemovedElementWithFocusData","scrollLeft","scrollTop","selectionStart","selectionEnd","selectionDirection","$2e682f50ad48c6fc$var$observeTag","tagFunction","tagResult","tagReaction","observe","oldTag","removedElementWithFocusData","contains","activeElement","allActiveLikeElements","findIndex","element","emptyDiv","createElement","replaceWith","elementToGiveFocus","elementIndexToGiveFocus","sort","targetIndex","indexA","indexB","Math","abs","setSelectionRange","exception","focus","$2e682f50ad48c6fc$var$setupEffectStore","$2e682f50ad48c6fc$var$getEffectStore","$2e682f50ad48c6fc$var$setEffectStore","$2e682f50ad48c6fc$var$restoreEffectStore","$2e682f50ad48c6fc$var$setupKeyQueue","$2e682f50ad48c6fc$var$getKeyQueue","$2e682f50ad48c6fc$var$setKeyQueue","$2e682f50ad48c6fc$var$restoreKeyQueue","$2e682f50ad48c6fc$var$processHooks","existingQueuedEffects","existingQueuedKeys","effectStoreName","effectStore","$2e682f50ad48c6fc$var$clearEffectStore","keyQueueName","keyQueue","splice","$2e682f50ad48c6fc$var$clearKeyQueue","existingEffects","queuedEffects","newKeys","newEffects","effect","newEffectKey","$119bc398b8498ab5$var$parseNodeAsString","Date","RegExp","toString","$119bc398b8498ab5$var$isNotWhitespace","test","$119bc398b8498ab5$var$appendChild","childs","lastChild","nodeName","nodeValue","createTextNode","nodeType","appendChild","$119bc398b8498ab5$exports","$5912e0d8006d4e74$var$isNotXMLNSprop","prop","$5912e0d8006d4e74$var$normalizeClassName","toLowerCase","$5912e0d8006d4e74$var$htmlForToFor","$5912e0d8006d4e74$var$nanoCreateElement","tag","props","children","createComment","comment","createElementNS","$5912e0d8006d4e74$var$containsOwnProp","$5912e0d8006d4e74$var$toObjectList","slice","eventKey","eventValue","events","$5912e0d8006d4e74$var$addEventToElement","$5912e0d8006d4e74$var$handleEventSetter","setAttributeNS","$5912e0d8006d4e74$var$handleAttrSetter","$5912e0d8006d4e74$exports","html","svg","$19b97d144575daf1$exports","domBuilder","h","components","eh","attrs","component","hx","$0dc8290522203a6e$exports","attr","$0dc8290522203a6e$var$transform","class","for","$bb4637dd63499816$exports","opts","comments","a","b","String","strfn","x","attrToProp","strings","state","reg","arglen","parts","i1","arg","p","parse","xstate","tree","stack","cur","s","ix","c","copyKey","j","shift","str","res","i","charAt","substr","$bb4637dd63499816$var$quot","$2e682f50ad48c6fc$var$registerDom","registry","hookedRegistry","reduce","newRegistry","stringifiedProps","JSON","stringify","workingKey","$2e682f50ad48c6fc$var$pushWorkingKeyBranch","uniqueBranch","$2e682f50ad48c6fc$var$copyWorkingKey","populatedTagFunction","restoreKey","branches","$2e682f50ad48c6fc$var$restoreWorkingKey","$2e682f50ad48c6fc$export$cd8b0dba543a4992","$2e682f50ad48c6fc$var$setupObservableStore","$2e682f50ad48c6fc$var$getObservableStore","$2e682f50ad48c6fc$require$observable","root","factory","define","notFound","routeDefinitions","routes","decode","decodeURIComponent","init","url","querySplit","replace","sanitize","split","esc","noop","ctx","hash","query","nameValue","params","processQuery","recurseUrl","lookup","pieces","rules","kv","piece","paramLen","recurseNamedUrl","val","subRules","route","handler","$528d53ce2c5024fa$exports","amd","Rlite","$b1b336c62b6dd252$var$onNonMatchingPath","matches","$b1b336c62b6dd252$var$returnParams","$422f3200d4cd2dd4$exports","$b1b336c62b6dd252$exports","getPath","pattern","$cd61df0301df60b5$exports","location","href","origin","setupUrlParams","useUrlParams","$2e682f50ad48c6fc$var$buildContainer","container","selectedElement","querySelector","$2e682f50ad48c6fc$var$getContainerElement","firstElementChild","containerChild","$2e682f50ad48c6fc$var$setupKeyStore","$2e682f50ad48c6fc$var$getKeyStore","$2e682f50ad48c6fc$var$setKeyStore","$2e682f50ad48c6fc$var$processTramTags","keyStoreName","keyStore","$2e682f50ad48c6fc$var$incrementKeyStoreValue","cleanup","effectReaction","$2e682f50ad48c6fc$require$observe","$2e682f50ad48c6fc$require$unobserve","$2e682f50ad48c6fc$var$removeStoreKeyAssociation","storeKeys","storeKey","$2e682f50ad48c6fc$var$clearNode","$2e682f50ad48c6fc$var$isTramOneComponent","$2e682f50ad48c6fc$var$childrenComponents","$2e682f50ad48c6fc$var$setupMutationObserver","$2e682f50ad48c6fc$var$getMutationObserver","MutationObserver","mutationList","flatMap","mutation","removedNodes","addedNodes","observableStore","observers","$2e682f50ad48c6fc$var$cleanUpObservableStores","$4eac7aaa79b8b8ef$var$$8a53a0cbd93d9a83$var$element","innerHTML","$4eac7aaa79b8b8ef$var$$parcel$interopDefault","$4eac7aaa79b8b8ef$export$2e2bcd8739ae039","$f43313d21d3fd8e2$var$html","childList","subtree","renderedApp","app","replaceChild","$2e682f50ad48c6fc$var$mount"],"version":3,"file":"index.dde330e5.js.map"}